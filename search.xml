<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编程通解 第一章 资质平平也要寻仙问道</title>
      <link href="/2021/11/12/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%A7%A3/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%A7%A3%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/11/12/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%A7%A3/%E7%BC%96%E7%A8%8B%E9%80%9A%E8%A7%A3%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>竹林里站着一个孩子，十来岁的孩子。</p><p>他什么也没做，只是站着，盯着竹子，满脸的愤懑。</p><p>他所在的竹林在陈家后山上，外人不得入内，所以，他自然也是陈家的人。</p><p>可惜，他的七品资质，在寻常人家里，能让邻里人前人后议论数月不止的七品资质，却让他快要做不了陈家的人了。</p><span id="more"></span><hr/><p>昨天是他的十二岁生日。</p><p>所有陈家的人，在十二岁时，都要进行资质测试，以便看出后辈潜力如何。</p><p>资质分为九品：<br>最低九品，测试石碑只会放出暗淡几乎不可见的灰色。<br>最高一品，据说能让资质测试的石碑放出耀眼的冲天赤芒，哪怕是白天，都能在十余里外看到。</p><p>若是寻常人家，资质有八品，便可以算上是人才，能让街坊羡慕好一阵子。</p><p>可惜，他偏偏生在了陈家，这个天才遍地的陈家。</p><hr/><p>陈家是元阳城里的三大家族之一，传承数百年，族人数千，几乎所有当铺、银行乃至珠宝店尽皆是陈家的生意。</p><p>大家族一代代优中择优，后辈自然也是要强于普通人。寻常人眼里，出类拔萃的七品资质，在陈家里，只能算是末流。</p><p>远支二爷爷家，堂兄陈睿，生来四品资质，测出当天，半个城都笼罩着祥瑞的紫色光辉。</p><p>城内，几十个堂姐、堂兄，更是没一人低于六品。</p><p>可是，自己资质却是只有七品。</p><hr/><p>陈原木然盯着竹子，像是要从竹子上看出自己的未来一样。</p><p>陈家对待资质平平的人，往往是不屑于培养，而往往是将其发配到外地建立分家。</p><p>若是日后还能发迹，方才允许其归宗，否则，便只是挂着陈家的名头，却得不到多少本家的帮助。</p><p>按往年的惯例，十二岁测完资质，不到半年，自己便会被分派到外地。</p><p>若是被分派，没有奇遇，除了年会等大事，一辈子都没机会回本家看看。</p><p>可是，资质先天赋生，天生天赐，后天不可增半分，也不可减半分。</p><p>自己便是再努力，又能改变什么呢？</p><hr/><p>“原儿！你在吗！”</p><p>竹林外传来女子声音。</p><p>这声音陈原很熟悉，陪伴了十余年所产生的熟悉。</p><p>是自己母亲的声音。</p><p>“原儿，你在里面吗？”</p><p>外面还在呼喊，陈原应了一声，朝着声音方向赶去。</p><hr/><p>“你这孩子，怎么钻这里，不怕受风寒啊。”</p><p>母亲脸上带着掩不住的喜色，但习惯性地唠叨了一句。</p><p>“今天传来消息，元始宗广收弟子，咱们陈家也有一个名额，你想不想去？”</p><p>“元始宗？”</p><p>陈原回味了一下这个名字。</p><p>元始宗是四年前才重开山门的宗派，据说门中曾有大能，抬手间焚山煮海，偷星换月。</p><p>可惜，千年之前，宗派人丁稀落，从此隐世。</p><p>不知是何缘故，又再次开放。</p><p>虽然盛名在外，但现下实力却不得而知，人们虽然感兴趣，却不愿意赌上自己前途，都只是观望。</p><p>“这元始宗的名额能落到我头上？”</p><p>陈原傻傻地问。</p><p>“本来是轮不到你，但是使者说，只收本家子弟。本家同辈大都想好了出路，没人来抢这名额。”</p><p>母亲解释道。</p><p>“这么好！”</p><p>陈原大喜过望，“我这就去报名！”</p><hr/><p>回到家里，问询了元始宗的使者，果真是本家无人愿去。</p><p>“报名需要什么条件吗？” 陈原问使者。</p><p>“这里有三个问题，根据你的答案，若是能符合要求，便可入门。” 使者应道。</p><p>“第一个问题，听好了。”</p><p>使者神色一凝，缓缓问道。</p><p>“上下未形，何由考之？冥昭瞢暗，谁能极之？”</p><p>陈原一愣。这是什么问题，怎么听都听不懂？</p><p>看着陈原一脸茫然，使者便不再等待，继续问道。</p><p>“接下来是第二个问题。”</p><p>“凡果皆有因，凡因皆有果。故知今者，可知下一瞬也，则见未来。故，生死有命，富贵在天？”</p><p>不等回答，使者又问：</p><p>“最后一个问题。”</p><p>“人，能胜天乎？”</p><p>陈原想了想，答道：</p><p>“我以为，生死有命，富贵在天，因果早有注定。故，人，不能胜天。”</p><p>“但，可以顺天，知其时，识其势。人不能胜天，但能胜己。”</p><p>听了陈原回答，使者点了点头。</p><p>“资质平平，心性尚可。口不妄言，有君子之风。”</p><p>“你的名字是？”</p><p>“陈原。” 陈原答道。</p><p>“好，回去收拾家当，三日后，我们便启程回宗。” 使者说。</p><p>说罢，使者身边浮现出一圈绿色符文，似乎密密麻麻写着什么。</p><p>符文光芒暴涨，随后收敛，使者也不见了踪影。</p><hr/><p>这是？</p><p>陈原虽然没有学过这些，自幼生长在大家之中，眼力却是不差。</p><p>使者所发动的似乎是八品符术【召灵术】，能用来隔空控物，能于目力之外制敌先机。</p><p>但八品符术本该散发出的白色光芒，在使者的手里却有着七品符术的绿光。</p><p>效果也不再是隔空控物，而是瞬间移动。</p><p>难道，元始宗，竟是这样一个化腐朽为神奇的地方？</p><p>陈原心底开始灼热起来。</p><p>自己，也有希望，化腐朽为神奇，走上寻仙问道的路了。</p><hr/><p>符术，人人都能学习的技能。通过将若干符文组合成符文条带，随后将符文条带编织而成。</p><p>资质越高的人，就能掌控更多的符文，从而发动更强大的符术。</p><p>而资质低的人，能掌控的符文数量少，符文条带的种类少，长度短，即使勉强发动符术，也威能不足。</p><p>根据学习难度，符文与符术都和资质一样分为九品，从其光芒就能辨识。</p><p>据说，有些特殊的符文与符术能无视品级规则，拥有自己的特殊光芒。</p><p>九品符术最是容易，普通人略加练习就能释放出，诸如【清心术】，让自己心灵宁静，【点火术】，在木柴表面生火，朴实而好用。</p><p>八品符术则要稍难一些，若是没有八品资质，得苦练数月才能学会，诸如能隔空控物的【召灵术】，能控制火焰大小的【控火术】等。</p><p>九品资质的人去学习七品符术，至少也得数年才能初步学会，而且发动也比较吃力。</p><p>陈原见过的七品符术不多，只有能看到百里外景象的【百里眼】，能控制天气的【驱云术】。</p><p>上次产业竣工，瞅准了黄道吉日，可惜天公不作美，下起了大雨。</p><p>本家几个到场的叔叔一同施展【驱云术】，直接变成艳阳天。</p><hr/><p>在十二岁之前，不能擅自凝练符文，否则会影响身体。</p><p>因此，陈原也只有一些纸上的知识。</p><p>他本期望，自己天资过人，以后施展符术手到擒来，却没料到，自己资质却只有七品。</p><p>期望落空，少年人心里自然满是不甘，所幸还有得补救。</p><p>元始宗虽然前途不明，却总比被发配到边远分家好。</p><p>况且，据传在宗门内，虽然没有操持家业的机会，却能学到很多符术的使用技巧，若是学成归来，不论在哪家，都能以符术大师的身份做客卿。</p><hr/><p>一边胡思乱想着未来，一边收拾东西，三日时间很快就结束了。</p><p>这些天里，陈原和各位长辈朋友都道了别，放下心去专攻符术，争取在元始宗里出人头地，干出一番事业来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程通解 编程思想 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh连接反应慢的解决方案</title>
      <link href="/2021/11/05/ssh%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%BA%94%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2021/11/05/ssh%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%BA%94%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>最近几次走 ssh 连接树莓派的时候，经常会发生连接速度较慢的问题，表现为每次按键后需要几秒时间才能反应过来，甚至直接断开连接，例如<a href="https://serverfault.com/questions/961576/ssh-lag-in-lan-on-some-machines-mixed-distros">局域网ssh延迟</a>这篇中所述的情况。</p><span id="more"></span><p>在发生延迟后，对树莓派ip进行一个的ping，然后，嘿嘿，ping炸了。</p><p>简单来说，ping 的时候，丢包率达到了<em><strong>喜人的 87%</strong></em> 以上。</p><p>哇，那怎么会这么高呢？</p><p>通过直接在树莓派上操作，网络什么也都正常。</p><p>唔，所以大致是 ping 不稳定，导致的 ssh 连接不稳？</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>首先，在<a href="https://www.annhe.net/article-4504.html">网上</a>看到了一个有趣的关键词：</p><p><strong>高效能以太网</strong></p><blockquote><p>高能效以太网（英语：Energy-Efficient Ethernet，简称EEE）是一套对双绞线与计算机网络标准之以太网家族的背板的增强，使其在低数据活动期间消耗较少的功率。</p><p>其目标是将功耗降低50%以上，同时保持与现有设备的完全兼容。</p><p>它的功率降低以几种方式实现。在100 Mbit&#x2F;s、1吉比特和10 Gbit&#x2F;s速度的数据链路中，物理层发送器会始终使用能量。</p><p>在没有数据发送时，它们可以进入“睡眠”模式以节约能源。<br>当控制器软件或固件确定不需要发送数据时，它可以发出一条“低功耗闲置”（LPI）请求到以太网控制器的物理层PHY。PHY然后将LPI信号在特定时间发送到链路上，以及禁用发送器。</p><p>信号刷新将周期性地发送以维持链路信令的完整性。当需要发送数据时，将在预定时间段发送IDLE信号。<br>数据链路可以被视为始终在运行，因为即使发送路径处在睡眠模式，接收信号的电路仍保持活跃。</p></blockquote><p>综上所述，可以看出，<strong>EEE会采用降低发送频率的方式节能</strong>。</p><p>执行该命令，查看是否启用了 EEE。</p><pre><code class="bash">ethtool --show-eee eth0</code></pre><p>通过观察可以看到，输出中，有 </p><blockquote><p>EEE status: enabled - active</p></blockquote><p>因此判断出，问题出现在 EEE 上。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><pre><code class="bash">sudo ethtool --set-eee eth0 eee off</code></pre><p>执行后再次检查 EEE 状态，可以看到其已关闭（disabled）。</p><p>为了保险，进行</p><pre><code class="bash">sudo service sshd restart</code></pre><p>从而解决问题，丝滑 ssh。</p><h2 id="长期配置"><a href="#长期配置" class="headerlink" title="长期配置"></a>长期配置</h2><p>可以将其加入开机启动项中，例如在 Raspberry 4B 上，可以将命令加入到 <code>/etc/rc.local</code> 中。</p><p>加入的命令如下：</p><pre><code class="bash">sudo ethtool --set-eee eth0 eee off</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ssh sshd 服务器 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TaiwuMods——从IDE到CSharp</title>
      <link href="/2020/03/26/TaiwuMods%E2%80%94%E2%80%94%E4%BB%8EIDE%E5%88%B0CSharp/"/>
      <url>/2020/03/26/TaiwuMods%E2%80%94%E2%80%94%E4%BB%8EIDE%E5%88%B0CSharp/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>因为一直怀疑VS装的有问题，所以打算卸载重装一下试试。</p><p>然后，以前的项目就打不开了。（指 Taiwu_Mods）</p><p>因此，大致记录一下过程，方便以后自己查。</p><span id="more"></span><h2 id="安装VS"><a href="#安装VS" class="headerlink" title="安装VS"></a>安装VS</h2><p>如题，不做描述。</p><p>需要特别注意的一点是，msbuild要构建C#项目，可能会出现找不到CMAKE_CSharp_COMPILER的情况。</p><p>参考 <a href="https://stackoverflow.com/questions/51668676/cmake-visual-studio-15-2017-could-not-find-any-instance-of-visual-studio">StackOverflow上的某篇教程</a>，可以得知，需要安装 Desktop development with C++ 组件。</p><p>也就是说，为了用cmake构建CSharp项目，需要VS中的.Net组件和桌面C++组件。（大概10G）</p>]]></content>
      
      
      
        <tags>
            
            <tag> VS CSharp Mods Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器基础配置过程</title>
      <link href="/2020/01/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/01/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>由于某些不可言说、无法理解的原因，我今天早上 00:00 的时候租了阿里云的轻量级服务器。</p><p>因为要配置相关环境，尤其指 Python 大礼包和 Anaconda（及 pyTorch），并且在过程中踩了很多坑，在其稍作记录。</p><span id="more"></span><h2 id="安装-conda"><a href="#安装-conda" class="headerlink" title="安装 conda"></a>安装 conda</h2><p>惊奇的是，conda 是有依赖的，其依赖 bzip2 包。</p><p>在参考了<a href="https://www.jianshu.com/p/1888984cad82">教程A</a>及<a href="https://www.cnblogs.com/xiao-apple36/p/9052102.html">教程B</a>后，记录如下：</p><p>首先安装依赖：</p><pre><code class="bash">sudo yum install bzip2 -y</code></pre><p>然后是下载</p><pre><code class="bash">wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2018.12-Linux-x86_64.sh</code></pre><p>下载的是清华源的某个稳定版本，内置 Python37。</p><p>接下来直接安装</p><pre><code class="bash">bash Anaconda3-4.4.0-Linux-x86_64.sh</code></pre><p>安装过程中，首先需要阅读协议并输入 yes。</p><p>随后安装到默认路径并且添加进 ~&#x2F;.vimrc 中。</p><p>至此，安装完成。</p><p>PS: 最后 anaconda 询问是否要下载 vs code，我选择了 no。</p><h2 id="安装-pytorch"><a href="#安装-pytorch" class="headerlink" title="安装 pytorch"></a>安装 pytorch</h2><p>首先是准备环境</p><p>pytorch 只能用在 python36 环境下，因此，我们使用</p><pre><code class="bash">conda create -n python36 python=3.6conda activate python36</code></pre><p>接下来，为了保证速度，添加一个下载源</p><pre><code class="bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes</code></pre><p>最后安装即可</p><pre><code class="bash">conda install pytorch torchvision</code></pre><p>需要注意的是，<code>conda install</code> 不要使用额外的 <code>-c</code> （指定源）参数。</p><p>参考<a href="https://blog.csdn.net/lykxhtp/article/details/81559046">教程</a></p><h2 id="安装-flask"><a href="#安装-flask" class="headerlink" title="安装 flask"></a>安装 flask</h2><p>在上面的 python36 环境中安装 flask 也不难。</p><p>参考<a href="https://www.cnblogs.com/linguanqiang/p/6706641.html">教程</a></p><pre><code class="bash">conda install flask</code></pre><p>输入该行即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 环境配置 centOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Everything成就获得攻略</title>
      <link href="/2019/12/22/Everything-Achievements/"/>
      <url>/2019/12/22/Everything-Achievements/</url>
      
        <content type="html"><![CDATA[<p>See the Help section when you press Esc in-game for information on how to do specific actions. (If the information about a particular action is not there it means you haven’t unlocked it yet, keep playing).</p><p>有关如何执行特定操作的信息，请在游戏中按Esc键时参阅“帮助”部分。（如果没有特定动作的信息，说明你还没有解锁，继续玩吧）。</p><p>If you know a more exact way of triggering an Achievement than it is written here, feel free to write it in the comments down below.</p><p>如果你知道一个比这里写的更准确的触发成就的方法，可以在下面的评论中写下来。</p><span id="more"></span><h2 id="Action-Achievements-行为类成就"><a href="#Action-Achievements-行为类成就" class="headerlink" title="Action Achievements 行为类成就"></a>Action Achievements 行为类成就</h2><p>Action Achievements can be obtained by doing specific actions in the game.</p><p>行为类成就可以通过在游戏中做特定的动作来获得。</p><p><strong>Thought Collector</strong>(Everything listens closely to itself) - Collect x Thoughts. (Press x while being near a Thing that has a speech bubble icon to collect a Thought)</p><p><strong>思想收藏家</strong>（每件事都密切地倾听自己）-收集x个思想。（靠近一个有语音气泡图标的物体时按x键可收集一个想法）</p><p><strong>Communicator</strong>(Everything hears itself sing) - Sing while being near other Things of the same kind. (Press spacebar to Sing)</p><p><strong>通信器</strong>（所有东西都能听到自己在唱歌）-在靠近同类事物时唱歌。（按空格键唱歌）</p><p><strong>A Merry Band</strong>(Everything gets itself mixed up) - Join with other Things. (Press v while being near other Things of the same kind to make them Join you, can be switched to the same category or everything when pressing q)</p><p><strong>一个快乐的乐队</strong>（一切都搞混了）-加入其他的乐队。（在靠近其他同类物品时按v键，使它们与您会合，按q键时可以切换到相同的类别或所有内容）</p><p><strong>The Swing Of Things</strong>(Everything sees itself through itself) - See your Thing in the world.</p><p><strong>事物的摆动</strong>（一切事物都通过自身看到自己）-看到你的世界。</p><p><strong>Bonder</strong>(Everything sees itself through everything) - Bond x times. (Hold the first mouse button to Bond into a smaller Thing or the second mouse button to Bond into a bigger Thing)</p><p><strong>邦德</strong>（一切都能看穿自己）-邦德x倍。（按住第一个鼠标键可绑定到较小的对象，或按住第二个鼠标键可绑定到较大的对象）</p><p><strong>Descender</strong>(Everything is the same all the way down) - Keep Descending until you reach the Subatomic level. (To Descend you need to be a small Thing in your current place, then a triangle will appear when you hold the first mouse button)</p><p><strong>下降</strong>（所有东西都是一样的）继续下降直到你达到亚原子水平。（要下降，您需要在当前位置成为一个小东西，然后当您按住第一个鼠标按钮时会出现一个三角形）</p><p><strong>Symmetrizer</strong>(Everything watches itself dance) - Dance for 10? minutes, then leave the dance by moving. (Press g while Joined with at least 1 other Thing to start Dancing) (Press v while being near other Things of the same kind to make them Join you, can be switched to the same category or everything when pressing q)</p><p><strong>对称器</strong>（所有东西都看着自己跳舞）-跳10个？几分钟后，离开舞蹈。（当与至少一个其他事物结合时按g开始跳舞）（当靠近其他同类事物时按v使它们与您结合，当按q时可以切换到相同的类别或所有内容）</p><p><strong>Thinker</strong>(Everything thinks about itself) - Think x times. (Press x when the ball&#x2F;eye at the top starts glowing to Think)</p><p><strong>思考者</strong>（一切都在思考自己）-思考x次。（当顶部的球&#x2F;眼睛开始发光思考时按x键）</p><p><strong>Becoming</strong>(Everything has the ability to transform itself) - Transform 1 time. (Hold e to Transform)</p><p><strong>成为</strong>（一切都有能力改变自己）-改变1次。（按住e键转换）</p><p><strong>No Such Things</strong>(Everything transforms itself over and over and over) - Transform x times. (Hold e to Transform)</p><p><strong>没有这样的东西</strong>（所有东西都会不断地自我转换）-转换x次。（按住e键转换）</p><p><strong>Nested Worlds</strong>(Everything has no dimensions) - Transform into a Planet, then Descend into it. (Hold e to Transform) (Keep Ascending until the Planetary level to unlock Planets)</p><p><strong>嵌套的世界</strong>（一切都没有维度）-转化成一个行星，然后下降到它。（按住e转换）（保持上升直到行星水平打开行星）</p><p><strong>This Is It</strong>(Everything renews itself) - Clear x Thoughts. (Press m to open your Thoughts, then hold c to clear them) (Press x while being near a Thing that has a speech bubble icon to collect a Thought)</p><p><strong>这就是它</strong>（一切都在自我更新）-清晰的x想法。（按m键打开您的想法，然后按住c键将其清除）（靠近带有语音气泡图标的对象时按x键收集想法）</p><p><strong>You Are Nothing</strong>(Everything is Nothing) - Collect all 66 audio clips. (Press x while being near a Thing that has a circle icon to listen to an audio clip and collect it) (Audio clips may repeat themselves in the world)</p><p><strong>你什么都不是</strong>（什么都不是）-收集所有66个音频剪辑。（靠近带有圆形图标的物体时按x键可收听并收集音频片段）（音频片段可能在世界上重复）</p><h2 id="Unlock-Achievements-解锁类成就"><a href="#Unlock-Achievements-解锁类成就" class="headerlink" title="Unlock Achievements 解锁类成就"></a>Unlock Achievements 解锁类成就</h2><p>Unlock Achievements can be obtained by unlocking Things in the game, to unlock Things you need to Bond with them once. (Hold the first mouse button to Bond into a smaller Thing or the second mouse button to Bond into a bigger Thing)</p><p>解锁类成就可以通过解锁游戏中的东西来获得，解锁你需要与之绑定一次的东西。（按住第一个鼠标键可绑定到较小的对象，或按住第二个鼠标键可绑定到较大的对象）</p><p><strong>Categoricalist</strong>(Everything opens itself wider and wider) - Unlock x categories of Things.</p><p><strong>分类学家</strong>（一切事物都会越来越广泛地开放自己）-打开x类事物。</p><p><strong>Structuralist</strong>(Everything finds itself in Structures) - Unlock over 50% of Things in the Building category.</p><p><strong>结构主义者</strong>（所有东西都在结构中找到自己）-打开建筑类别中超过50%的东西。</p><p><strong>Cold Blood</strong>(Everything finds itself in Reptiles) - Unlock over 50% of Things in the Reptile category.</p><p><strong>冷血</strong>（一切都在爬行动物身上找到）-开启爬行动物类中超过50%的东西。</p><h2 id="Other-Achievements-其他成就"><a href="#Other-Achievements-其他成就" class="headerlink" title="Other Achievements 其他成就"></a>Other Achievements 其他成就</h2><p>Other Achievements that can be obtained in the game.</p><p>其他可以在游戏中获得的成就。</p><p><strong>Welcome To Everything</strong> (Everything finally begins) - Finish the tutorial. (It’s quite a lengthy one)</p><p><strong>欢迎来到一切</strong>（一切终于开始了）-完成教程。（相当长）</p><p><strong>Destroyer Of Worlds</strong> (Everything destroys itself) - Obtain 30~50 Disasters. (Disasters will appear in the world when your PC can’t handle the game&#x2F;the game has low FPS, Disasters appear as random things&#x2F;words appearing on the screen with loud sounds. Best way to achieve Disasters is to add a lot of Things that move around and enlarge all of them while Joined in the Galactic level)</p><p><strong>世界毁灭者</strong>（万物毁灭自己）-获得30~50次灾难。（当你的电脑无法处理游戏&#x2F;游戏的帧速率较低时，灾难就会出现在世界上，灾难会以随机事件&#x2F;文字的形式出现在屏幕上，声音很大。实现灾难的最好方法是添加大量的东西，这些东西在加入银河系时会四处移动并放大所有的东西）</p><p><strong>Everything is Everything</strong> (Everything is Everything) - Unlock all other Achievements.</p><p><strong>一切就是一切</strong>（一切就是一切）-开启所有其他成就。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Everything 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的链表及二叉树学习</title>
      <link href="/2019/11/29/%E7%AE%80%E5%8D%95%E7%9A%84%E9%93%BE%E8%A1%A8%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/29/%E7%AE%80%E5%8D%95%E7%9A%84%E9%93%BE%E8%A1%A8%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本节课将会讲三点内容，链表，栈以及二叉树。</p><span id="more"></span><!-- toc --><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>先来看一个简单的题目：</p><h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><p> n个人围成一圈，从第一个人开始报数，数到m的人出列，再由下一个人重新从1开始报数，数到m的人再出圈，……依次类推，直到所有的人都出圈，请输出依次出圈人的编号。</p><p><strong>输入</strong></p><p>一行有两个数字，n和m，如题意。</p><p><strong>输出</strong></p><p>一行，为所有出圈人的编号。</p><p><strong>样例</strong></p><table><thead><tr><th align="left">输入</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left">10 3</td><td align="left">3 6 9 2 7 1 8 5 10 4</td></tr></tbody></table><p><strong>数据范围</strong></p><p>1 &lt;&#x3D; m &lt;&#x3D; n &lt;&#x3D; 100</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>约瑟夫问题是一个典型的模拟问题。</p><h4 id="第一种思路（数组标记）"><a href="#第一种思路（数组标记）" class="headerlink" title="第一种思路（数组标记）"></a>第一种思路（数组标记）</h4><p>我们可以创建一个数组，数组长度不小于总人数，每当一个人出列时，在数组内做一个标记。</p><pre><code class="cpp">int a[105];// ...int num=n,last=1;    while(num)&#123;        int cnt=0;        for(int i=last;cnt!=m;i++)&#123;            if(i&gt;n) i%=n;            if(a[i]==-1) continue;            ++cnt;            if(cnt==m)&#123;                a[i]=-1;                num--;                last=i+1;                printf(&quot;%d &quot;,i);                break;            &#125;        &#125;    &#125;</code></pre><h4 id="第二种思路（索引数组）"><a href="#第二种思路（索引数组）" class="headerlink" title="第二种思路（索引数组）"></a>第二种思路（索引数组）</h4><p>我们需要一种存储方式，能够在修改后快速找到下一个有效位置，而不是顺序检查。</p><p>不妨采用这样的方式：</p><pre><code class="cpp">int prev[105], next[105];// ...for(int i=1; i&lt;=n; ++i)&#123;    prev[i] = ((i-1)-1+n)%n+1;    next[i] = ((i-1)+1  )%n+1;&#125;// ...// 去掉 下标 i 的人next[prev[i]] = next[i];prev[next[i]] = prev[i];</code></pre><h4 id="第三种思路（索引链表）"><a href="#第三种思路（索引链表）" class="headerlink" title="第三种思路（索引链表）"></a>第三种思路（索引链表）</h4><p>上面的 prev 和 next 是分离的，有时候进行一些处理时可能不够直观，因此我们采用数据结构——链表。</p><p>先定义一个整合了 prev 和 next 的结构体：</p><pre><code class="cpp">struct Node&#123;    int prev;    int next;&#125;;</code></pre><p>如果是 C，为了便于编程，在下面再加一行</p><pre><code class="c">typedef struct Node Node;</code></pre><p>在使用的时候，采用这种方式</p><pre><code class="cpp">Node a[105];// ...// 去掉 下标 i 的人a[a[i].prev].next = a[i].next;a[a[i].next].prev = a[i].prev;</code></pre><p>这种方式的使用有一些限制，其中最显然的一点是，a，也即是存储这些 Node 的对象，必须是可以使用整数作为索引的。</p><p>对于数组（和上节课描述过的 <code>std::vector</code> 、 <code>template&lt;typename T&gt; std::map&lt;int, T&gt;</code> 以及<code>std::set&lt;int&gt;</code> ）来说，这一假设可以满足，但是对于更多的情况，这一假设可能会限制我们的使用。</p><p>其次，这种方式使用时，还暗示了，删除一个元素很容易，然而增加新元素却很难。</p><p>考虑到 c 和 cpp 中常见的获取新的存储空间的方式（c：<code>malloc</code> ，<code>realloc</code> 和 <code>calloc</code> ；cpp：<code>new</code> ），我们可以认为，指针是一种通用的存储方式，因此，如果能用指针表示 prev 和 next ，我们就可以避免被上面的限制所束缚。</p><h4 id="第四种思路（链表）"><a href="#第四种思路（链表）" class="headerlink" title="第四种思路（链表）"></a>第四种思路（链表）</h4><p>在这里，我们选择使用指针作为索引。</p><pre><code class="cpp">struct Node&#123;    int id;    Node *prev;    Node *next;&#125;;</code></pre><p>如果是 C 语言，请在最前面加上 <code>typedef struct Node Node;</code></p><p>去掉某个人，则采用这样的方法：</p><pre><code class="cpp">void remove(Node *p)&#123;    if(p-&gt;prev &amp;&amp; p-&gt;next)    &#123;        p-&gt;prev-&gt;next = p-&gt;next;        p-&gt;next-&gt;prev = p-&gt;prev;        delete p;        // if in c, use free    &#125;&#125;</code></pre><p>最后一种方式的优点在于，我们不需要事先准备一个足够大的数组，而是可以根据输入数据动态创建一个足够长的链。</p><h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。<br>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 </p><p>例如，一个长度为 3 的链表可以是这样的。</p><pre class="mermaid">graph LR;    A-->B;    B-->C;    A["A: 1 | &B"];    B["B: 3 | &C"];    C["C: 12 | NULL"];</pre><p>这个链表共有三个元素，A-C。其中 A 的数据域为 1，指针域为 &amp;B（B的地址）。最后的 C 数据域为 12，指针域为空（NULL）。可以使用一个循环来遍历这个链表：</p><pre><code class="cpp">struct Node&#123;    int v;    Node *next;&#125;;Node *head = GetHead();</code></pre><pre><code class="cpp">for(Node *p = head; p; p = p-&gt;next)&#123;    printf(&quot;%d\n&quot;, p-&gt;v);&#125;</code></pre><h3 id="链表和数组对比"><a href="#链表和数组对比" class="headerlink" title="链表和数组对比"></a>链表和数组对比</h3><p>此处的数组指广义数组（含<code>std::array</code> 及<code>std::vector</code>）</p><table><thead><tr><th align="left">对比项</th><th align="left">链表</th><th>数组</th></tr></thead><tbody><tr><td align="left">查找第 n 个元素</td><td align="left">O(n)</td><td>O(1)</td></tr><tr><td align="left">删去第 n 个元素</td><td align="left">O(1)</td><td>O(n)</td></tr><tr><td align="left">插入元素到某位置</td><td align="left">O(1)</td><td>O(n)</td></tr><tr><td align="left">将某一段逆序</td><td align="left">O(n)</td><td>O(n)</td></tr></tbody></table><h3 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h3><ul><li>单链表<ul><li>数据域：数据；</li><li>指针域：next 指针，表示其下一个节点的地址</li></ul></li><li>循环链表<ul><li>单链表</li><li>最后一个节点的 next 为首个节点的地址</li></ul></li><li>双向链表<ul><li>指针域：next 指针和 prev 指针，分别表示下一个节点和上一个节点的地址。</li></ul></li></ul><h3 id="链表-in-STL"><a href="#链表-in-STL" class="headerlink" title="链表 in STL"></a>链表 in STL</h3><p>STL 中也有链表类型的实现：std::list</p><p>其支持的方法如下：</p><table><thead><tr><th><strong>list成员</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>operator&#x3D;</td><td>赋值重载运算符</td></tr><tr><td>assign</td><td>分配值</td></tr><tr><td>front</td><td>返回第一个元素的引用</td></tr><tr><td>back</td><td>返回最后一元素的引用</td></tr><tr><td>begin</td><td>返回第一个元素的指针(iterator)</td></tr><tr><td>end</td><td>返回最后一个元素的下一位置的指针</td></tr><tr><td>rbegin</td><td>返回链表最后一元素的后向指针(reverse_iterator or const)</td></tr><tr><td>rend</td><td>返回链表第一元素的下一位置的后向指针</td></tr><tr><td>push_back</td><td>增加一元素到链表尾</td></tr><tr><td>push_front</td><td>增加一元素到链表头</td></tr><tr><td>pop_back</td><td>pop_back()删除链表尾的一个元素</td></tr><tr><td>pop_front</td><td>删除链表头的一元素</td></tr><tr><td>clear</td><td>删除所有元素</td></tr><tr><td>erase</td><td>删除一个元素或一个区域的元素(两个重载)</td></tr><tr><td>remove</td><td>删除链表中匹配值的元素(匹配元素全部删除)</td></tr><tr><td>remove_if</td><td>删除条件满足的元素(遍历一次链表)，参数为自定义的回调函数</td></tr><tr><td>empty</td><td>判断是否链表为空</td></tr><tr><td>max_size</td><td>返回链表最大可能长度</td></tr><tr><td>size</td><td>返回链表中元素个数</td></tr><tr><td>resize</td><td>重新定义链表长度(两重载函数)</td></tr><tr><td>reverse</td><td>反转链表</td></tr><tr><td>sort</td><td>对链表排序，默认升序</td></tr><tr><td>merge</td><td>合并两个有序链表并使之有序</td></tr><tr><td>splice</td><td>对两个链表进行结合(三个重载函数) 结合后第二个链表清空</td></tr><tr><td>insert</td><td>在指定位置插入一个或多个元素(三个重载函数)</td></tr><tr><td>swap</td><td>交换两个链表(两个重载)</td></tr><tr><td>unique</td><td>删除相邻重复元素</td></tr></tbody></table><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p><p>如：<code>3*(5–1)+7</code>对应的后缀表达式为：<code>3 5 1 - * 7 +</code>。</p><p><strong>输入</strong></p><p>一行，其中运算符和运算数之间都用空格分隔，运算数是一个一位非负整数。</p><p><strong>输出</strong></p><p> 一行，表达式的值。</p><p><strong>样例</strong></p><table><thead><tr><th align="left">输入</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left">3 5 1 - * 7 +</td><td align="left">19</td></tr></tbody></table><p><strong>数据范围</strong></p><p>无。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个问题看似麻烦，我们不妨先来手动模拟一次。</p><p>3 5 1 - * 7 +</p><p>首先参与运算的是 “5 1 -“ ，得到结果 4，将 4 填在原来 “5 1 -“ 的位置。</p><p>这时候，表达式为 3 4 * 7 +</p><p>我们接下来算乘法，得到结果 12</p><p>现在表达式为 12 7 +</p><p>两者相加，得到结果 19。</p><hr><p>通过观察我们的求解过程，我们可以发现，我们每次选择最靠前的一个符号，并将其前方的两个数字进行运算。</p><p>但是具体实现起来该如何做呢？</p><p><font size=5><del>&gt;&gt;&gt;&gt;<strong>栈</strong>&lt;&lt;&lt;&lt;</del></font></p><p>结合前面的知识，我们发现，可以使用一个链表，这个链表结构如下：</p><pre><code class="cpp">struct Node&#123;    int type;    int v;    Node *next, *prev;&#125;;</code></pre><p>其中，type 表示其为数字还是为运算符。</p><p>如果是数字，v 表示 数字的值；如果为运算符，我们不妨用 0123 代指四种运算符。</p><p>接下来，每次从首个节点开始查找，找到第一个 <code>type == 运算符</code> 的节点，然后获得其前方的两个节点的值，运算后用其结果代替这三个节点。</p><p>等到最后，首元素的 next 为 NULL 的时候，即链表长度为 1 时，最后这个节点的 v 就是结果。</p><p><del> 所以跟栈有什么关系 </del></p><h3 id="使用栈来解题"><a href="#使用栈来解题" class="headerlink" title="使用栈来解题"></a>使用栈来解题</h3><p>观察我们的解题思路，我们可以发现这样一个特点。</p><p>我们每次处理的时候，都只对前面的一部分数据进行处理。</p><p>如下：</p><ol><li><p><font color=gree>3 </font><font color=blue>5 1 </font><font color=red>-</font> <font color=gray>* 7 +</font></p></li><li><p><font color=blue>3 4 </font><font color=red>*</font> <font color=gray>7 +</font></p></li><li><p><font color=blue>12 7 </font><font color=red>+</font></p></li><li><p><font color=blue>19</font></p></li></ol><p>其中，我们可以发现，绿色和灰色的部分是完全不用考虑的。</p><p>每次操作是找到红色的操作符，然后取出蓝色的数字，进行运算后放回对应位置。</p><p>如果我们不看灰色部分，我们可以得到这样的操作流程：</p><p>每次取出最后一个节点（操作符），然后再取出两个节点作为操作数，运算后将结果放回原位置。</p><p>我们归纳这个过程，可以抽象出这样的行为：</p><ol><li><p>取出元素：从一系列元素的最后面获得一个元素，元素数量减一；</p></li><li><p>放入元素：在一系列元素的最后面添加一个元素，元素数量加一。</p></li></ol><p>在栈中，我们将这两个操作称为 push 和 pop。push 是压入一个元素，而 pop 是弹出一个元素。</p><hr><p>通过整理上面的过程，我们可以得到这样的流程：<br>首先创建一个栈，然后读入数据，每当读入一个元素，就将一个元素压栈。（这里的元素包括数字和操作符）</p><p>如果刚刚压栈的是操作符，就弹出三个元素，按照出栈的顺序记为 a，b，c（其中，a 是刚刚压栈的操作符），并将 c (a) b 的结果压栈。</p><p>直到读入完数据后，栈中剩余一个元素，这个元素就是结果。</p><hr><p><strong>更加简洁</strong></p><p>上面的方法中，每次操作符被压栈后就立即出栈，而这一过程可以被简化：</p><p>输入数据：</p><p>如果数据为 数字 ，则压栈；</p><p>如果数据为 操作符，则弹出两个数字，并将运算结果压栈。</p><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>栈（stack）又名堆栈，它是一种运算受限的线性表。<br>限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。<br>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；<br>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p><strong>栈的特点可以概括为 FILO (First In Last Out)，即越先进去的元素，越后出来</strong></p><h3 id="栈的常见实现"><a href="#栈的常见实现" class="headerlink" title="栈的常见实现"></a>栈的常见实现</h3><ol><li>可以用数组和一个数字模拟栈</li><li>STL std::stack</li><li>用链表来实现栈。</li></ol><h3 id="提及队列"><a href="#提及队列" class="headerlink" title="提及队列"></a>提及队列</h3><p>队列与栈相似，不同点在于其为先进先出。</p><h3 id="线性数据结构对比"><a href="#线性数据结构对比" class="headerlink" title="线性数据结构对比"></a>线性数据结构对比</h3><table><thead><tr><th align="left"></th><th align="left">数组（广义）</th><th>链表</th><th>栈</th><th>队列</th></tr></thead><tbody><tr><td align="left">支持下标操作（随机寻址）</td><td align="left">是</td><td>否</td><td>否</td><td>否</td></tr><tr><td align="left">增删元素的复杂度</td><td align="left">O(n)</td><td>O(1)</td><td>&#x2F;</td><td>&#x2F;</td></tr><tr><td align="left">支持遍历所有元素</td><td align="left">是</td><td>是</td><td>否</td><td>否</td></tr><tr><td align="left">求指定位置元素的复杂度</td><td align="left">O(1)</td><td>O(n)</td><td>&#x2F;</td><td>&#x2F;</td></tr><tr><td align="left">在末端增加新元素复杂度</td><td align="left">O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td align="left">能访问的元素数量</td><td align="left">所有</td><td>所有</td><td>仅栈顶</td><td>仅队首</td></tr><tr><td align="left">能操作的位点数量</td><td align="left">所有</td><td>所有</td><td>仅栈顶</td><td>队首和队尾</td></tr></tbody></table><pre class="mermaid">graph TB;    A[数组]-->C[栈];    A-->B;    B[链表]-->C;    A-->D[队列];    B-->D;</pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="后缀表达式转中缀表达式"><a href="#后缀表达式转中缀表达式" class="headerlink" title="后缀表达式转中缀表达式"></a>后缀表达式转中缀表达式</h3><p>后缀表达式定义如前，请根据给定后缀表达式，采用完全加括号的形式，输出其确定的中缀表达式。</p><p>如：<code>3*(5–1)+7</code>对应的后缀表达式为：<code>3 5 1 - * 7 +</code>，我们对其完全加括号，可以得到<code>((3*(5-1))+7)</code> 。</p><p><strong>输入</strong></p><p>一行，其中运算符和运算数之间都用空格分隔，运算数是一个一位非负整数。</p><p><strong>输出</strong></p><p> 一行，中缀表达式。</p><p><strong>样例</strong></p><table><thead><tr><th align="left">输入</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left">3 5 1 - * 7 +</td><td align="left">((3*(5-1))+7)</td></tr></tbody></table><p><strong>数据范围</strong></p><p>无。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>针对样例，我们可以发现，有这样的层级结构</p><pre class="mermaid">graph TB;    A["((3*(5-1))+7)"]-->B["(3*(5-1))"];    A-->C["7"];    B-->D["3"];    B-->E["(5-1)"];    E-->F["5"];    E-->G["1"];</pre><p>每个表达式可以被抽象为 <code>(a op b)</code> 的形式，其中，a、b 为表达式，op 为操作符。</p><p>表达式有两种形式：<code>(a op b)</code> 或者 <code>a</code> ，其中 a、b 为表达式，op 为操作符。</p><p>也就是说，表达式可以是单个数字。</p><p>通过看图，我们可以发现，3、5、1、7 这四个节点，也就是操作数节点，没有下属节点（后称“子节点”）。<br>而当其有子节点的时候，如 <code>(5-1)</code> ，有两个操作数节点，因此有一层括号。</p><p>我们将其所有子节点的层数，取其中的最大值，称之为该节点的深度。<br>例如，<code>(5-1)</code> 深度为 1，<code>3</code> 深度为 0，而最终结果的深度为 <code>max(3, 1) = 3</code>。<br>对于深度为 d 的节点，其有 d 层括号。</p><p>因为这个层级结构像一棵倒置的树，因此这一结构被称为“树”。最上面的节点被称为根节点，而没有子节点的节点被称为叶节点。</p><pre class="mermaid">graph TB;    A["根节点 ((3*(5-1))+7)"]-->B["(3*(5-1))"];    A-->C["叶节点 7"];    B-->D["叶节点 3"];    B-->E["(5-1)"];    E-->F["叶节点 5"];    E-->G["叶节点 1"];</pre><p>也就是说，其结构如上所示。</p><p>对于每一组这样结构的节点</p><pre class="mermaid">graph TB;    A["亲节点"]-->B["左子节点"];    A-->C["右子节点"];</pre><p>其中 A 被称为亲节点（或父节点），而 B、C 则称之为子节点。</p><p>亲节点和子节点的定义的相对的，没有绝对的亲节点，也没有绝对的子节点。<br>特别的，仅当节点数量为 1 时，树中不存在亲节点与子节点的关系。</p><p>像表达式树这种，每个节点（最多）有两个子节点的情况，我们分别将这两个子节点称为左子节点和右子节点。而这个树称之为二叉树。</p><h3 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h3><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>一棵深度为k，且有2^k-1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子结点，至多有2k-1个结点。</p><h3 id="怎么解题？"><a href="#怎么解题？" class="headerlink" title="怎么解题？"></a>怎么解题？</h3><p>对于上面的题目，我们可以这样做：</p><p>将栈（后缀表达式）部分的计算过程进行修改。</p><p><strong>原来的过程是：</strong></p><p>输入一个元素；</p><p>如果是数字则压栈；</p><p>如果是操作符则出栈两个数字，运算后压栈。</p><p><strong>在这里，我们修改过程：</strong></p><p>输入一个元素；</p><p>如果是数字，则压栈一个值为此数字的节点；</p><p>如果是操作符，则出栈两个节点，生成新的节点后压栈。</p><p><strong>表达式的保存</strong></p><p>我们可以采用这样的结构：</p><pre><code class="cpp">struct Node&#123;    bool isNum;    int val;    Node *left, *right;&#125;;</code></pre><p>这样一来，上面的树就可以如下表示：</p><pre class="mermaid">graph TB;    A["A: false | '+' | &B | &C"]-->B["B: false | '*' | &D | &E"];    A-->C["C: true | 7 | NULL | NULL"];    B-->D["D: true | 3 | NULL | NULL"];    B-->E["E: false | '-' | &F | &G"];    E-->F["F: true | 5 | NULL | NULL"];    E-->G["G: true | 1 | NULL | NULL"];</pre><p>通过观察我们可以发现，所有叶节点都是操作数，非叶节点都是操作符。</p><p>因此我们可以使用这样的结构：</p><pre><code class="cpp">struct Node&#123;    int val;    Node *left, *right;&#125;;</code></pre><pre class="mermaid">graph TB;    A["A: '+' | &B | &C"]-->B["B: '*' | &D | &E"];    A-->C["C: 7 | NULL | NULL"];    B-->D["D: 3 | NULL | NULL"];    B-->E["E: '-' | &F | &G"];    E-->F["F: 5 | NULL | NULL"];    E-->G["G: 1 | NULL | NULL"];</pre><p>而要判断一个节点是操作数还是操作符，可以如下判断：</p><pre><code class="cpp">bool isNum(Node *p)&#123;    return p-&gt;left == NULL &amp;&amp; p-&gt;right == NULL;&#125;</code></pre><p>在生成这样一个树形结构后，我们就可以进行输出。</p><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><blockquote><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p><p>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历，也叫先序遍历），LDR（称为中根次序遍历，也叫中序遍历），LRD （称为后根次序遍历，也叫后序遍历）。</p></blockquote><p>要输出表达式，我们采用中序遍历的方式。</p><p>对于每个节点，如果其为表达式，则遍历输出，如果为数字，则直接输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 社团课程 零基础课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象入门</title>
      <link href="/2019/11/11/OO-Basic-basedoncpp/"/>
      <url>/2019/11/11/OO-Basic-basedoncpp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>If you think C++ is not overly complicated, just what is a protected abstract virtual base pure virtual private destructor and when was the last time you needed one?</p><footer><strong>[Tom Cargill]</strong></footer></blockquote><span id="more"></span><p>本文通篇将会构造一个类，并以此类的构造过程为讲解顺序。</p><p>本文需求的先修知识：cpp <em>iostream</em> (<code>std::cin,std::cout</code> &amp; <code>std::endl</code>)，cpp <em>class defination</em>, c <em>struct</em>, c <em>pointer</em> and cpp <em>keywords</em> (<code>const, new, delete, class, public, private</code> [<code>protected, pure, virtual</code>])</p><!-- toc --><hr><h2 id="编程目标"><a href="#编程目标" class="headerlink" title="编程目标"></a>编程目标</h2><p>在命令行窗口编程时，我们有时候会希望输出一些特定的格式，如：（每行前面有一个空格）</p><pre><code> Hello, World!</code></pre><p>像这样的，基于字符构造的，有特定格式、内容的整体，我们姑且称之为 “字符图像”。<br>我们可以给字符图像加上边框：</p><pre><code>.-------.| Hello,|| World!|&#39;-------&#39;</code></pre><p>更多地，可能会希望支持两个这样的字符图拼接，形成新的图像。</p><pre><code>.-------.| Hello,| 你好，| World!| 世界！&#39;-------&#39;</code></pre><p>以及希望能够修改边框的样式等等······</p><hr><h2 id="面向过程可以吗？"><a href="#面向过程可以吗？" class="headerlink" title="面向过程可以吗？"></a>面向过程可以吗？</h2><p>如我们所学过的 C&#x2F;Cpp， 我们可能会想到这样做：</p><pre><code class="cpp">int main()&#123;    const char *content[] = &#123;&quot;Hello,&quot;, &quot;World!&quot;&#125;;    int left_padding = 1;    for(int i=0; i&lt;2; ++i)    &#123;        for(int j=0; j&lt; left_padding; ++j) printf(&quot; &quot;);        printf(&quot;%s&quot;, content[i]);        printf(&quot;\n&quot;);    &#125;&#125;</code></pre><p>运行可以得到输出：</p><pre><code> Hello,  World!</code></pre><p>但是很显然，这样无法（很难）对多个字符图进行操作。</p><h2 id="C-语言也能面向对象吗？"><a href="#C-语言也能面向对象吗？" class="headerlink" title="C 语言也能面向对象吗？"></a>C 语言也能面向对象吗？</h2><p>我们需要将一个图视为一个对象，一个物体，才能方便地管理、输出两个（及以上）的图。</p><h3 id="C-语言面向对象"><a href="#C-语言面向对象" class="headerlink" title="C 语言面向对象"></a>C 语言面向对象</h3><p><em>如果下面的例程编译错误，请修改文件后缀为 cpp 或添加编译选项 -std&#x3D;c99 或 -std&#x3D;c11</em></p><p>我们用 C 语言来试试看：</p><pre><code class="c">struct tagPicture&#123;    char **m_content;    int m_padding_left, m_padding_top;    int m_height, m_width;&#125;;typedef struct tagPicture Picture;</code></pre><p>在这个结构体 <code>struct tagPicture</code> （或记作<code>Picture</code>）中，我们使用 <code>m_content</code> 来保存图像内容，<code>m_height, m_width</code> 表示图像的宽与高，<code>m_padding_left</code> 和<code>m_padding_top</code> 表示图像左侧和上侧内边界大小。</p><p>怎么创建一个 <code>Picture</code> 呢？<br>在 C 语言中，我们需要定义一个函数来创建该类型：</p><pre><code class="c">// 此处需要库文件 stdlib.h 和 string.hPicture getPicture(const char **_ArrayOfCharArray, int _Lines)&#123;    Picture t;    t.m_content = (char **) malloc(_Lines *sizeof(char *));    t.m_padding_left = t.m_padding_top = 0;    t.m_height = _Lines;    t.m_width = 0;    for(int i=0; i&lt;_Lines; ++i)    &#123;        int n = _ArrayOfCharArray[i] ? strlen(_ArrayOfCharArray[i]) : 0;        if( t.m_width &lt; n ) t.m_width = n;     &#125;    for(int i=0; i&lt;_Lines; ++i)    &#123;        t.m_content[i] = (char *) malloc((t.m_width+1) * sizeof(char));        strcpy(t.m_content[i], _ArrayOfCharArray[i]);    &#125;    return t;&#125;</code></pre><p>还需要设定一个输出用的函数：</p><pre><code class="c">// 此处需要库文件 stdio.hvoid printPicture(Picture _pic)&#123;    for(int i=0; i&lt;_pic.m_height; ++i)    &#123;        if(!(i &lt; _pic.m_padding_top))        &#123;            for(int j=0; j&lt;_pic.m_width; ++j)            &#123;                if(j &lt; _pic.m_padding_left) printf(&quot; &quot;);                else if(_pic.m_content[j-_pic.m_padding_left])                    printf(&quot;%c&quot;, _pic.m_content[i-_pic.m_padding_top][j-_pic.m_padding_left]);                else break;            &#125;        &#125;        if(i+1 != _pic.m_height) printf(&quot;\n&quot;);    &#125;&#125;</code></pre><p>接下来在主函数调用试试：</p><pre><code class="c">int main()&#123;    const char *content[] = &#123;&quot;Hello,&quot;, &quot;World!&quot;&#125;;    Picture a = getPicture(content, 2);//  a.m_padding_left = 1;    printPicture(a);&#125;</code></pre><p>编译运行后可以得到这样的输出：</p><pre><code>Hello,World!</code></pre><p>我们在主函数中将 <code>a.m_padding_left</code> 设置为 1，则会看到：</p><pre><code> Hello World</code></pre><h3 id="有何缺陷？"><a href="#有何缺陷？" class="headerlink" title="有何缺陷？"></a>有何缺陷？</h3><p>首先，我们的这个图像单个输出、存储都没有问题，但是如果想要拼接，尤其是横向拼接，就很难做，其次，进行其他复杂操作时，不能较容易地存储结构信息。</p><h3 id="C语言课后习题"><a href="#C语言课后习题" class="headerlink" title="C语言课后习题"></a>C语言课后习题</h3><ul><li>课后习题 1 : 经过上面的示例，我们可以发现纵向拼接很容易，在此处不做详解，将 C 语言面向对象实现图像的纵向拼接这一任务留作习题。</li><li>课后习题 2 : 纵向拼接实现很轻松，横向拼接相对来说难度略大，但聪明的读者一定能解决这个问题，请用 C 语言面向对象实现图像的横向拼接。</li><li>课后习题 3 : 请用 C 语言面向对象实现给图像加边框，边框样式需要作为函数参数，如可以指定用 ‘*‘ 来画边框。</li><li>课后习题 4 : 请用 C 语言面向对象实现图像修改边框样式，例如将 ‘*’ 样式的边框改为 ‘+’ 样式。</li></ul><h2 id="Cpp-面向对象"><a href="#Cpp-面向对象" class="headerlink" title="Cpp 面向对象"></a>Cpp 面向对象</h2><p>Cpp 的 class、struct 与 C 中的 struct 相似。</p><table><thead><tr><th align="center"></th><th align="center">C struct</th><th align="center">Cpp struct</th><th align="center">Cpp class</th></tr></thead><tbody><tr><td align="center">Plain Old Data</td><td align="center">true</td><td align="center">false</td><td align="center">false</td></tr><tr><td align="center">default access rights</td><td align="center">&#x2F;</td><td align="center">public</td><td align="center">private</td></tr><tr><td align="center">member function enable</td><td align="center">false</td><td align="center">true</td><td align="center">true</td></tr></tbody></table><p>简单用法在此不做赘述。<br>不妨先实现上面程序的内容，让我们看看能否更加优雅。</p><h3 id="构造和输出功能"><a href="#构造和输出功能" class="headerlink" title="构造和输出功能"></a>构造和输出功能</h3><p>我们姑且以此结构构造程序：</p><pre><code>src |-- main.cpp |-- Picture.h &#39;-- Picture.cpp</code></pre><p>首先得定义这个类，并声明其方法。</p><pre><code class="cpp">#ifndef __PICTURE__INC#define __PICTURE__INCclass Picture&#123;public:    Picture(const char **_Strs, int _Lines);    void print(void);private:    char **m_content;    int m_width, m_height;    int m_padding_left, m_padding_top;&#125;;#endif</code></pre><p>接下来我们在主函数内直接定义 Picture 的实例 pic，并以此初始化字符串数组初始化这个实例。</p><p>此后，我们调用其输出方法。</p><pre><code class="cpp">//main.cpp#include &quot;picture.h&quot;const char *initstrs[] = &#123;&quot;Hello,&quot;, &quot;World!&quot;&#125;;int main()&#123;    Picture pic(initstrs, 2);    pic.print();&#125;</code></pre><p>最后，我们实现这两个函数。</p><pre><code class="cpp">// picture.cpp#include &quot;picture.h&quot;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt; Picture::Picture(const char **_Strs, int _Lines)&#123;    m_content = (char **) malloc(_Lines *sizeof(char *));    m_padding_left = m_padding_top = 0;    m_height = _Lines;    m_width = 0;    for(int i=0; i&lt;_Lines; ++i)    &#123;        int n = _Strs[i] ? strlen(_Strs[i]) : 0;        if( m_width &lt; n ) m_width = n;     &#125;    for(int i=0; i&lt;_Lines; ++i)    &#123;        m_content[i] = (char *) malloc((m_width+1) * sizeof(char));        strcpy(m_content[i], _Strs[i]);    &#125;&#125;void Picture::print(void)&#123;    for(int i=0; i&lt;m_height; ++i)    &#123;        if(!(i &lt; m_padding_top))        &#123;            for(int j=0; j&lt;m_width; ++j)            &#123;                if(j &lt; m_padding_left) printf(&quot; &quot;);                else if(m_content[j-m_padding_left])                    printf(&quot;%c&quot;, m_content[i-m_padding_top][j-m_padding_left]);                else break;            &#125;        &#125;        if(i+1 != m_height) printf(&quot;\n&quot;);    &#125;&#125;</code></pre><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>对于 Picture 来说，管理内存比较容易，只需要给其添加一个析构函数即可。</p><pre><code class="cpp">// picture.h@@ -5,6 +5,7 @@ &#123; public:        Picture(const char **_Strs, int _Lines);+       ~Picture(void);        void print(void); private:        char **m_content;</code></pre><pre><code class="cpp">@@ -23,6 +23,13 @@        &#125; &#125;+Picture::~Picture(void)+&#123;+       for(int i=0; i&lt;m_height; ++i)+               free(m_content[i]);+       free(m_content);+&#125;+ void Picture::print(void) &#123;        for(int i=0; i&lt;m_height; ++i)</code></pre><h3 id="怎么纵向连接？俯瞰继承关系"><a href="#怎么纵向连接？俯瞰继承关系" class="headerlink" title="怎么纵向连接？俯瞰继承关系"></a>怎么纵向连接？俯瞰继承关系</h3><p>首先我们要知道，纵向连接后的结果也应该是一个 Picture，并能够继续纵向连接。</p><h4 id="我们应该怎样设计呢？"><a href="#我们应该怎样设计呢？" class="headerlink" title="我们应该怎样设计呢？"></a>我们应该怎样设计呢？</h4><p>这里引入一个概念：继承</p><p>如下，是图形之间的继承关系。<br>我们可以认为，如果 A 指向 B ，那么 B 属于 A。</p><p><em>这里涉及到面向对象设计的基本理念，目前主流思路有两种：is-a，has-a <del>和 like-a</del>。</em></p><pre class="mermaid">graph TB;    Shape-->Polygen;    Shape-->Ellipse;    Polygen-->Rectange;    Ellipse-->Circle;    Rectange-->Square;</pre><p>在我们这个例子中，我们有理由认为，Picture 是所有类型的基础。<br>我们可以想当然如此构造：</p><pre class="mermaid">graph TB;    Picture --> vCatPicture;    Picture --> hCatPicture;</pre><p>这时候出现了一个问题：我们连接两个图像的时候，应该使用类型本身呢，还是使用其指针呢？<br>例如上面的图形例子，Rectangle 类型（通常）可以无损转化为 Square 类型，但是 Rectangle 类型的指针不能转换为 Square 类型的指针。相反的，Square 类型（通常）不能无损转换为 Rectangle 类型，但是 Square * 类型却可以实现到 Rectangle * 的转换。</p><p>指针类型并不方便，而值类型（及引用类型）并不能支持这样的转换。</p><p>如果采用指针类型的话，我们需要定制这样的框架：</p><pre class="mermaid">graph TB;    Picture-->BasicPicture;    Picture-->vCatPicture;    Picture-->hCatPicture;    Picture-->FramedPicture;</pre><p>其中，<code>BasicPicture</code> 表示纯文本的图，<code>vCatPicture</code> 表示经过了一次垂直连接，<code>hCatPicture</code> 表示经过一次水平连接，<code>FramedPicture</code> 表示加框架的图。<br>在具体使用时，我们使用 Picture * 来表示所有可能的类型。</p><p>而值类型则不同，值类型只能从上游向下游转换（从亲代到子代），因此只能是这两种情况之一（或其组合形式）。</p><pre class="mermaid">graph TB;    A-->D;    B-->D;    C-->D;    a==>b;    b==>c;    c==>d;</pre><p>显然，这两种构造都无法用 is-a 来解释，用 has-a 解释也很勉强。因此，这是一种不合理的构造方式。</p><p><strong>因此，我们采用指针来进行运算，采用共同基类来实现</strong>。</p><hr><h4 id="我们需要哪些类型呢？"><a href="#我们需要哪些类型呢？" class="headerlink" title="我们需要哪些类型呢？"></a>我们需要哪些类型呢？</h4><p><code>BasicPicture</code> ：保存实际的图像（字符串）内容，及其宽度与高度。<br><code>vCatPicture</code> ，<code>hCatPicture</code> ：保存其所连接的两图像指针<br><code>FramedPicture</code> ：保存一个图像指针及其边框内容。</p><p>基于这些类型，我们可以容易地实现图像连接，图像解除连接，图像加边框，图像去边框以及修改内容。</p><hr><h4 id="我们怎样管理内存？"><a href="#我们怎样管理内存？" class="headerlink" title="我们怎样管理内存？"></a>我们怎样管理内存？</h4><p>之前的例子里，我们采用构造函数分配内存，析构函数释放内存的方式来处理内存问题。</p><p>但是，如下所示的，在断点处，<code>FramedPicture b</code> 的内容物（a）已经被析构，因此输出 b 可能是一个非法操作。</p><pre><code class="cpp">FramedPicture b;&#123;    BasicPicture a = ...;    b = enframe(a);&#125;// breakpoint</code></pre><p>经过一系列思考，我们可以推理出引用计数的必要性。</p><h3 id="类型的设计"><a href="#类型的设计" class="headerlink" title="类型的设计"></a>类型的设计</h3><h4 id="Picture-类"><a href="#Picture-类" class="headerlink" title="Picture 类"></a>Picture 类</h4><p>经过思考，我们设计这样一个 <code>Picture</code> 类。</p><pre><code class="cpp">class Picture&#123;public:    Picture(void);    Picture(const char* const *, int);    Picture(const Picture&amp;);    ~Picture(void);    Picture&amp; operator=(const Picture&amp;);    void reframe(int p, char c);    void reframe(char c, char v, char h);    Picture split(int id);private:    PictureEntity *ap ;    Picture(PictureEntity* p);    int width(void) const;    int height(void) const;    std::ostream&amp; display(std::ostream&amp;, int, int) const;&#125;;</code></pre><p>最上面的三个构造函数，分别有以下作用：</p><pre><code class="cpp">Picture::Picture(void); // 构造一个空的 Picture 对象Picture::Picture(const char* const *, int); // 根据字符串指针和其行数构造一个 PicturePicture::Picture(const Picture&amp;); // 拷贝构造函数，例如</code></pre><p><code>reframe</code> 函数用来重设框架格式。<br><code>private</code> 内容则是对外不可见的具体实现。<br><code>PictureEntity *ap</code> 是一个指针，这里的 <code>PictureEntity</code> 即为上面设计中的所有类型的基类 。<br>剩余的函数姑且不考虑。</p><h4 id="PictureEntity-基类"><a href="#PictureEntity-基类" class="headerlink" title="PictureEntity 基类"></a>PictureEntity 基类</h4><p>这个类型，作为所有行为的具体呈现者，并且是一个基类，我们如此定义：</p><pre><code class="cpp">class PictureEntity&#123;public:    PictureEntity(void);    virtual ~PictureEntity(void) = 0;    virtual void incuse(void) = 0;    virtual int decuse(void) = 0;    friend class Picture;protected:    int use;    virtual int width(void) const = 0;    virtual int height(void) const = 0;    virtual ostream&amp; display(ostream&amp;, int, int) const = 0;    ostream&amp; fillEmpty(ostream&amp;, int, int, char _ch = &#39; &#39;) const;    static int max(int a, int b);    virtual void reframe(int pos, char c);    virtual void reframe(char corner, char vlimit, char hlimit);    virtual Picture split(int id) = 0;&#125;</code></pre><p>首先看 <code>public:</code> 部分：<br>继承中的基类必须拥有虚析构函数，在这里，为了防止创建 <code>PictureEntity</code> 的实例，我们将其析构函数设置为纯虚析构函数。<br>其次，其拥有两个对引用进行处理的函数，且均为纯虚函数。</p><p>其次看 <code>protected</code> ：<br><code>use</code> 为引用计数器。<br>其他的函数作用如其名所示。</p><p>这个类无法被实例化。</p><h4 id="BasicPicture"><a href="#BasicPicture" class="headerlink" title="BasicPicture"></a>BasicPicture</h4><pre><code class="cpp">class BasicPicture : public PictureEntity&#123;public:    BasicPicture(const char* const*, int);    ~BasicPicture(void);    void incuse(void);    int decuse(void);    int width(void) const;    int height(void) const;    ostream&amp; display(ostream&amp;, int, int)const;        Picture split(int id);private:    char **m_data;    int m_size;    int *m_width;    int m_maxwidth;&#125;;</code></pre><p>这个类型看起来更像是我们在<a href="#%E6%9E%84%E9%80%A0%E5%92%8C%E8%BE%93%E5%87%BA%E5%8A%9F%E8%83%BD">前面</a> 里面实现的类型。其用法也与之相似。</p><h4 id="FramedPicture"><a href="#FramedPicture" class="headerlink" title="FramedPicture"></a>FramedPicture</h4><pre><code class="cpp">class FramedPicture : public PictureEntity&#123;public:    FramedPicture(const Picture&amp;, char c, char v, char h);    FramedPicture(const Picture&amp;, char ct, char cb, char v, char h);    FramedPicture(const Picture&amp;, char ct, char cb, char t, char b, char l, char r);    FramedPicture(const Picture&amp;, char c1, char c2, char c3, char c4, char t, char b, char l, char r);    ~FramedPicture(void);    void incuse(void);    int decuse(void);        void reframe(int pos, char c);    void reframe(char corner, char v, char h);    int width(void) const;    int height(void) const;    ostream&amp; display(ostream&amp;, int y, int mw) const;        Picture split(int id);    friend Picture enframe(const Picture&amp;);private:    Picture m_insidePic;    char c1, c2, c3, c4;    char l, r, t, b;&#125;;</code></pre><p>这个类型 <code>public:</code> 部分有大量构造函数，其余部分与上面的<code>BasicPicture</code> 相似。</p><h4 id="VcatPicture"><a href="#VcatPicture" class="headerlink" title="VcatPicture"></a>VcatPicture</h4><pre><code class="cpp">class VcatPicture : public PictureEntity&#123;public:    VcatPicture(const Picture&amp;, const Picture&amp;);    ~VcatPicture(void);    void incuse(void);    int decuse(void);        int width(void)const ;    int height(void)const ;    ostream&amp; display(ostream&amp;, int y, int mw) const;    Picture split(int id);    friend Picture operator&amp;(const Picture&amp;, const Picture&amp;);private:    Picture top, bottom;&#125;;</code></pre><p>这个类表示 <code>top</code> 和 <code>bottom</code> 纵向连接。</p><h4 id="HcatPicture"><a href="#HcatPicture" class="headerlink" title="HcatPicture"></a>HcatPicture</h4><pre><code class="cpp">class HcatPicture :public PictureEntity&#123;public:    HcatPicture(const Picture&amp;, const Picture&amp;);    ~HcatPicture(void);    void incuse(void);    int decuse(void);        int width(void)const ;    int height(void)const ;    ostream&amp; display(ostream&amp;, int y, int mw) const;    Picture split(int id);    friend Picture operator|(const Picture&amp;, const Picture&amp;);private:    Picture left, right;&#125;;</code></pre><hr><h2 id="总述及效果展示"><a href="#总述及效果展示" class="headerlink" title="总述及效果展示"></a>总述及效果展示</h2><p>通过上面从<a href="#%E6%80%8E%E4%B9%88%E7%BA%B5%E5%90%91%E8%BF%9E%E6%8E%A5%EF%BC%9F%E4%BF%AF%E7%9E%B0%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">继承关系设计</a> 到 <a href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1">类型的具体设计</a> ，我们基本有了程序的框架。</p><p>在经过具体实现这些类型后，我们就得到了完整的<a href="../../../../resources/CharacterPicture.zip">代码</a>。</p><h3 id="Cpp-课后习题"><a href="#Cpp-课后习题" class="headerlink" title="Cpp 课后习题"></a>Cpp 课后习题</h3><ul><li>课后习题 1 : 经过上面的示例，我们可以发现一个给定的图可以唯一确定一个（系列性的）输出动作，而 <code>std::string</code> 也可以唯一确定一个输出动作，请将一个给定的图转换为 <code>std::string</code> 。</li><li>课后习题 2 : 请设计一个类，可以独立保存一张图及其结构信息。</li><li>课后习题 3 : 习题 2 自然不难，能否将这个类的 <code>std::cin</code> 和<code>std::cout</code> 的对应操作重载，使其能够被保存和读取。</li><li>课后习题 4 : 如果将<code>&#39;*&#39;</code> 视为黑色，<code>&#39; &#39;</code> 视为白色，那么任何一张只有黑白两色的图可以唯一确定一个字符图，请设计一个方法，能够根据一张图片（<code>.jpg</code> 或<code>.png</code>）生成一个字符图。（可以利用第三方库读入图片）</li><li>课后习题 5 : 相信对于聪明的读者们，习题 4 比较容易。请在习题 4 的基础上，支持字符图的旋转、平移等图形操作。</li><li>课后习题 6 : 其实根据字符密度，<a href="../../../../resources/thirdeye.txt">纯字符方式</a>可以表现黑白灰色彩（单通道八位），请在习题 4 的基础上，生成一个可以生成黑白灰色彩的图。（如 <code>&#39; &#39;</code> 表示纯黑，<code>&#39;■&#39;</code> 表示纯白，<code>&#39;*&#39;</code> 表示一种灰色）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 社团课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib编码字体错误的解决过程</title>
      <link href="/2019/11/07/matplotlib%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/11/07/matplotlib%E7%BC%96%E7%A0%81%E5%AD%97%E4%BD%93%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>众所周知，设置 matplotlib 输出中文需要：</p><p>plt.rcParams[‘font.sans-serif’]&#x3D;[‘SimHei’]  # 用来正常显示中文标签<br>plt.rcParams[‘axes.unicode_minus’]&#x3D;False  # 用来正常显示负号</p><span id="more"></span><p>第一行是设置字体（推荐使用 <code>.insert(0, fontname)</code> 而非直接赋值）</p><p>第二行则是设置减号（<code>-</code> ）采用 ASCII 码查找字体，而非 unicode 编码。</p><p>但是，在使用过程中发生了错误。</p><p>复现错误：</p><pre><code class="python"># -*- coding: UTF-8 -*-%matplotlib inlineimport matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falseplt.figure(figsize=(18,9))data = [0.001*(10**i) for i in range(4)]bins = 10**(np.linspace(-3, 2))plt.hist(data, bins = bins, label = &#39;test&#39;)plt.xscale(&#39;log&#39;)plt.ylabel(&#39;English test&#39;)plt.title(&#39;汉字测试&#39;)plt.show()</code></pre><p>会发生这样的错误：</p><blockquote><pre><code>%pythonlib%\matplotlib\mathtext.py:849: MathTextWarning: Font &#39;default&#39; does not have a glyph for &#39;-&#39; [U+2212]  MathTextWarning)%pythonlib%\matplotlib\mathtext.py:850: MathTextWarning: Substituting with a dummy symbol.  warn(&quot;Substituting with a dummy symbol.&quot;, MathTextWarning)</code></pre></blockquote><p>我们可以认为是 ‘-‘ 导致的出错。</p><p>通过在 github 上的 <a href="https://github.com/matplotlib/matplotlib">matplotlib 项目</a> 查找，可以找到这个文件 <a href="https://github.com/matplotlib/matplotlib/blob/master/examples/text_labels_and_annotations/unicode_minus.py">matplotlib&#x2F;examples&#x2F;text_labels_and_annotations&#x2F;unicode_minus.py</a> ，通过看文件名，大致可知其为 <code>unicode_minus</code> 的示例文件。</p><p>内容如下：</p><pre><code class="python">&quot;&quot;&quot;=============Unicode minus=============By default, tick labels at negative values are rendered using a `Unicodeminus`__ (U+2212) rather than an ASCII hyphen (U+002D).  This can be controlledby setting :rc:`axes.unicode_minus`.__ https://en.wikipedia.org/wiki/Plus_and_minus_signs#Character_codesThe replacement is performed at draw time of the tick labels (usually during a`.pyplot.show()` or `.pyplot.savefig()` call). Therefore, all tick labels ofthe figure follow the same setting and we cannot demonstrate both glyphs onreal tick labels of the same figure simultaneously.Instead, this example simply showcases the difference between the two glyphsin a magnified font.&quot;&quot;&quot;import matplotlib.pyplot as pltfig = plt.figure(figsize=(4, 2))fig.text(.15, .6, &quot;Unicode minus:&quot;, fontsize=20)fig.text(.85, .6, &quot;\N&#123;MINUS SIGN&#125;1&quot;, ha=&#39;right&#39;, fontsize=20)fig.text(.15, .3, &quot;ASCII hyphen:&quot;, fontsize=20)fig.text(.85, .3, &quot;-1&quot;, ha=&#39;right&#39;, fontsize=20)plt.show()</code></pre><p>可知，<code>unicode_minus</code> 设置为 <code>False</code> 时，理应不使用 U+2212 输出，而是使用 U+002D，然而上面的错误信息却试图输出 U+2212，我们可以认为是这个选项没有起到作用。</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>通过注释，我们可以发现出现警告的原因是<code>plt.xscale(&#39;log&#39;)</code> 一行。</p><p>不妨在库源码中追溯来源。</p><pre><code class="python">import matplotlib.pyplot as plt</code></pre><p>由此可知，错误是在 <code>matplotlib.pyplot.xscale</code> 调用时出现的。</p><p>追溯<code>matplotlib.pyplot.xscale</code> 可得：</p><pre><code class="python">def xscale(*args, **kwargs):    gca().set_xscale(*args, **kwargs)</code></pre><p>首先判断 <code>gca()</code> 类型，由 <code>print(gca().__module__)</code> 输出 <code>matplotlib.axes._subplots</code> 。</p><p>打开对应模块，会发现找不到 <code>gca()</code> 的定义。</p><p>改为 <code>print(type(gca()))</code> ，输出<code>&lt;class &#39;matplotlib.axes._subplots.AxesSubplot&#39;&gt;</code> 。</p><p>虽然未能找到 <code>AxesSubplot</code> ，但是观察可得，<code>AxesSubplot</code> 应该是 <code>matplotlib.axes._subplots.SubplotBase</code>  的一个子类&#x2F;别名。</p><p>然而，在该基类中未能找到对应的函数。</p><p>由于 python 具有反射机制，我们想当然地去<code>matplotlib\axes\_base.py</code> 中，在<code>matplotlib.axes._base._AxesBase</code> 内，可以找到</p><pre><code class="python">    def set_xscale(self, value, **kwargs):        g = self.get_shared_x_axes()        for ax in g.get_siblings(self):            ax.xaxis._set_scale(value, **kwargs)            ax._update_transScale()            ax.stale = True        self.autoscale_view(scaley=False)</code></pre><p>简单分析可知，我们出错的情况下， <code>set_xscale</code> 传入参数为 <code>set_xscale(this, &#39;log&#39;)</code> 。</p><p>也即通过该函数呈递给  <code>ax.xaxis._set_scale(value, **kwargs)</code> ，此时<code>value = &#39;log&#39;, kwargs=&#123;&#125;</code> 。</p><p>在呈递前插入</p><pre><code class="python">            print(type(ax.xaxis))</code></pre><p>得到输出<code>&lt;class &#39;matplotlib.axis.XAxis&#39;&gt;</code> 。</p><p>由于<code>XAxis</code> 继承于<code>Axis</code> ，搜索<code>_set_scale</code> 可发现其定义于后者，即基类中。</p><pre><code class="python">    def _set_scale(self, value, **kwargs):        self._scale = mscale.scale_factory(value, self, **kwargs)        self._scale.set_default_locators_and_formatters(self)        self.isDefault_majloc = True        self.isDefault_minloc = True        self.isDefault_majfmt = True        self.isDefault_minfmt = True</code></pre><p>通过尝试输出<code>self._scale</code> ，可以得到缩放类型为<code>&quot;log&quot;</code> 时，该变量类型为<code>matplotlib.scale.LogScale</code> 。</p><p>目前，我们可以得到这样的呈递关系图：</p><pre class="mermaid">graph TB;    plt-->gca;    gca-->axis;    axis-->mscale;    plt[pyplot.xscale&#40'log'&#41]gca[axes._subplots.set_xscale&#40'log'&#41]axis[axis.XAxis._set_scale&#40'log'&#41]mscale[scale.LogScale.set_default_locators_and_formatters&#40&#41]</pre><p>根据</p><pre><code class="python">class LogitScale(ScaleBase):    ...</code></pre><pre><code class="python">_scale_mapping = &#123;    &#39;linear&#39;: LinearScale,    &#39;log&#39;:    LogScale,    &#39;symlog&#39;: SymmetricalLogScale,    &#39;logit&#39;:  LogitScale,    &#125;</code></pre><pre><code class="python">def scale_factory(scale, axis, **kwargs):    &quot;&quot;&quot;    Return a scale class by name.    ACCEPTS: [ %(names)s ]    &quot;&quot;&quot;    scale = scale.lower()    if scale is None:        scale = &#39;linear&#39;    if scale not in _scale_mapping:        raise ValueError(&quot;Unknown scale type &#39;%s&#39;&quot; % scale)    return _scale_mapping[scale](axis, **kwargs)scale_factory.__doc__ = cbook.dedent(scale_factory.__doc__) % \    &#123;&#39;names&#39;: &quot; | &quot;.join(get_scale_names())&#125;</code></pre><p>可得<code>self._scale = mscale.scale_factory(&#39;log&#39;)</code> 等价于<code>self._scale = mscale.LogScale(self)</code> 。</p><p>到 <code>class &#39;matplotlib.scale.LogScale&#39;</code> 中可以看到方法</p><pre><code class="python">    def set_default_locators_and_formatters(self, axis):        &quot;&quot;&quot;        Set the locators and formatters to specialized versions for        log scaling.        &quot;&quot;&quot;        axis.set_major_locator(LogLocator(self.base))        axis.set_major_formatter(LogFormatterSciNotation(self.base))        axis.set_minor_locator(LogLocator(self.base, self.subs))        axis.set_minor_formatter(            LogFormatterSciNotation(self.base,                                    labelOnlyBase=(self.subs is not None)))</code></pre><p>观察易知，其分别设置刻度的标值和格式。</p><p>将设置四行改为</p><pre><code class="python">        axis.set_major_locator(NullLocator())        axis.set_major_formatter(NullFormatter())        axis.set_minor_locator(NullLocator())        axis.set_minor_formatter(NullFormatter())</code></pre><p>可以发现，<code>plt.show()</code> 没有了水平刻度值，也没有警告信息。</p><p>通过观察可知，<code>set_major_XXX</code> 控制刻度值，而<code>set_minor_XXX</code> 控制刻度格。</p><p>并且错误原因在于<code>axis.set_major_formatter(LogFormatterSciNotation(self.base))</code> 。</p><p>因为 <code>LogScale</code> 默认以 10 为底（<code>self.base</code> ），因此可知该句等价于</p><p><code>Axis.set_major_formatter(LogFormatterSciNotation(10))</code></p><p>其中，<code>LogFormatterSciNotation</code> 类型为 <code>matplotlib.ticker.LogFormatterSciNotation</code> 。</p><hr><p>根据输出的警告信息，我们在对应位置前生成一个异常，可以得到</p><pre><code class="python">matplotlib\mathtext.py in __init__(self, c, state, math)   1454         # The real width, height and depth will be set during the   1455         # pack phase, after we know the real fontsize-&gt; 1456         self._update_metrics()   1457    1458     def __internal_repr__(self):matplotlib\mathtext.py in _update_metrics(self)   1461     def _update_metrics(self):   1462         metrics = self._metrics = self.font_output.get_metrics(-&gt; 1463             self.font, self.font_class, self.c, self.fontsize, self.dpi, self.math)   1464         if self.c == &#39; &#39;:   1465             self.width = metrics.advancematplotlib\mathtext.py in get_metrics(self, font, font_class, sym, fontsize, dpi, math)    456             &quot;height&quot;.    457         &quot;&quot;&quot;&quot;&quot;&quot;&quot; # 为了不影响代码高亮，补全引号--&gt; 458         info = self._get_info(font, font_class, sym, fontsize, dpi, math)    459         return info.metrics    460 matplotlib\mathtext.py in _get_info(self, fontname, font_class, sym, fontsize, dpi, math)    579     580         font, num, symbol_name, fontsize, slanted = \--&gt; 581             self._get_glyph(fontname, font_class, sym, fontsize, math)    582     583         font.set_size(fontsize, dpi)matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    907             # otherwise return regular glyph    908             return super(DejaVuFonts, self).\_get_glyph(fontname,--&gt; 909                     font_class, sym, fontsize, math)    910     911 matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    787     788     def _get_glyph(self, fontname, font_class, sym, fontsize, math=True):--&gt; 789         raise &quot;test&quot;    790         found_symbol = False    791 </code></pre><p>此时的 fontname 为 ‘default’，应当改为其他内容（以满足条件 <code>fontname in (&#39;it&#39;, &#39;regular&#39;)</code> ）</p><hr><p>经测试，改 UnicodeFonts 类中 _get_glyph 内 fontname 为 ‘it’ 可解决问题。</p><p>经测试，改 TruetypeFonts 类中 _get_info 方法的 fontname 为 ‘it’ 也可解决问题。</p><p>经测试，改 Fonts 基类中的 get_metrics 方法的 font 为 ‘it’ 无效。</p><p>在 _get_info 添加输出，可以发现其被多处调用。</p><p>重新获取另一调用链，可得</p><pre><code class="python">matplotlib\mathtext.py in group(self, s, loc, toks)   2814    2815     def group(self, s, loc, toks):-&gt; 2816         grp = Hlist(toks[0])   2817         return [grp]   2818     required_group = simple_group = groupmatplotlib\mathtext.py in __init__(self, elements, w, m, do_kern)   1609         List.__init__(self, elements)   1610         if do_kern:-&gt; 1611             self.kern()   1612         self.hpack()   1613 matplotlib\mathtext.py in kern(self)   1631    1632                 new_children.append(elem)-&gt; 1633                 kerning_distance = elem.get_kerning(next)   1634                 if kerning_distance != 0.:   1635                     kern = Kern(kerning_distance)matplotlib\mathtext.py in get_kerning(self, next)   1486                 self.font, self.font_class, self.c, self.fontsize,   1487                 next.font, next.font_class, next.c, next.fontsize,-&gt; 1488                 self.dpi)   1489         return advance + kern   1490 matplotlib\mathtext.py in get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi)    634                  font2, fontclass2, sym2, fontsize2, dpi):    635         if font1 == font2 and fontsize1 == fontsize2:--&gt; 636             info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)    637             info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)    638             font = info1.fontmatplotlib\mathtext.py in _get_info(self, fontname, font_class, sym, fontsize, dpi, math)    580     581         font, num, symbol_name, fontsize, slanted = \--&gt; 582             self._get_glyph(fontname, font_class, sym, fontsize, math)    583     584         font.set_size(fontsize, dpi)matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    909             # otherwise return regular glyph    910             return super(DejaVuFonts, self)._get_glyph(fontname,--&gt; 911                     font_class, sym, fontsize, math)    912     913 matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    840                 else:    841                     return self.cm_fallback._get_glyph(--&gt; 842                         fontname, font_class, sym, fontsize)    843             else:    844                 if fontname in (&#39;it&#39;, &#39;regular&#39;) and isinstance(self, StixFonts):matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    845                     return self._get_glyph(&#39;rm&#39;, font_class, sym, fontsize)    846                 print(fontname)--&gt; 847                 raise &#39;error&#39;    848                 warn(&quot;Font &#39;%s&#39; does not have a glyph for &#39;%s&#39; [U+%x]&quot; %    849                      (new_fontname,</code></pre><p>为了方便此后调试，在改动部分加上 <code># RecoDebugging</code> 。</p><p>该次 Bug 出错在于 <code>mathtext.Char.font = &#39;default&#39;</code> ，经过捕捉可发现其被 <code>state.font</code> 赋值，即 <code>matplotlib.mathtext.Parser.State.font</code> 。</p><p>追踪这个构造函数调用，可得</p><pre><code class="python">matplotlib\mathtext.py in symbol(self, s, loc, toks)   2638         c = toks[0]   2639         try:-&gt; 2640             char = Char(c, self.get_state())   2641         except ValueError:   2642             raise ParseFatalException(s, loc, &quot;Unknown symbol: %s&quot; % c)matplotlib\mathtext.py in __init__(self, c, state, math)   1449         self.c = c   1450         self.font_output = state.font_output-&gt; 1451         raise &#39;test&#39;   1452         self.font = state.font   1453         self.font_class = state.font_class</code></pre><p>观察 <code>matplotlib.mathtext.Parser.symbol</code> 可得，<code>Parser.State</code> 构造函数被调用于 </p><pre><code class="python">matplotlib\mathtext.py in parse(self, s, fonts_object, fontsize, dpi)   2513         Returns the parse tree of :class:`Node` instances.   2514         &quot;&quot;&quot;&quot;&quot;&quot; # end the comment-&gt; 2515         self._state_stack = [self.State(fonts_object, &#39;default&#39;, &#39;rm&#39;, fontsize, dpi)]   2516         self._em_width_cache = &#123;&#125;   2517         try:C:\ProgramData\Anaconda3\lib\site-packages\matplotlib\mathtext.py in __init__(self, font_output, font, font_class, fontsize, dpi)   2540         &quot;&quot;&quot;&quot;&quot;&quot;  # end the comment   2541         def __init__(self, font_output, font, font_class, fontsize, dpi):-&gt; 2542             raise &#39;generate state&#39;   2543             self.font_output = font_output   2544             self._font = font</code></pre><p>最终可以发现，<code>state</code> 被赋值于此处，只需要修改 <code>matplotlib.mathtext.Parser.parse</code> 即可结束此支错误。</p><hr><p>暂改为 ‘it’，运行仍然出错，主动抛出异常，捕获链如下：</p><pre><code class="python">matplotlib\mathtext.py in group(self, s, loc, toks)   2815    2816     def group(self, s, loc, toks):-&gt; 2817         grp = Hlist(toks[0])   2818         return [grp]   2819     required_group = simple_group = groupmatplotlib\mathtext.py in __init__(self, elements, w, m, do_kern)   1609         List.__init__(self, elements)   1610         if do_kern:-&gt; 1611             self.kern()   1612         self.hpack()   1613 matplotlib\mathtext.py in kern(self)   1631    1632                 new_children.append(elem)-&gt; 1633                 kerning_distance = elem.get_kerning(next)   1634                 if kerning_distance != 0.:   1635                     kern = Kern(kerning_distance)matplotlib\mathtext.py in get_kerning(self, next)   1486                 self.font, self.font_class, self.c, self.fontsize,   1487                 next.font, next.font_class, next.c, next.fontsize,-&gt; 1488                 self.dpi)   1489         return advance + kern   1490 matplotlib\mathtext.py in get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi)    634                  font2, fontclass2, sym2, fontsize2, dpi):    635         if font1 == font2 and fontsize1 == fontsize2:--&gt; 636             info1 = self._get_info(font1, fontclass1, sym1, fontsize1, dpi)    637             info2 = self._get_info(font2, fontclass2, sym2, fontsize2, dpi)    638             font = info1.fontmatplotlib\mathtext.py in _get_info(self, fontname, font_class, sym, fontsize, dpi, math)    580     581         font, num, symbol_name, fontsize, slanted = \--&gt; 582             self._get_glyph(fontname, font_class, sym, fontsize, math)    583     584         font.set_size(fontsize, dpi)matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    909             # otherwise return regular glyph    910             return super(DejaVuFonts, self)._get_glyph(fontname,--&gt; 911                     font_class, sym, fontsize, math)    912     913 matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    840                 else:    841                     return self.cm_fallback._get_glyph(--&gt; 842                         fontname, font_class, sym, fontsize)    843             else:    844                 if fontname in (&#39;it&#39;, &#39;regular&#39;) and isinstance(self, StixFonts):matplotlib\mathtext.py in _get_glyph(self, fontname, font_class, sym, fontsize, math)    845                     return self._get_glyph(&#39;rm&#39;, font_class, sym, fontsize)    846                 #print(fontname)--&gt; 847                 raise &#39;error&#39; # RecoDebugging    848                 warn(&quot;Font &#39;%s&#39; does not have a glyph for &#39;%s&#39; [U+%x]&quot; %    849                      (new_fontname,</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作主题时踩的坑</title>
      <link href="/2019/10/22/%E5%88%B6%E4%BD%9C%E4%B8%BB%E9%A2%98%E6%97%B6%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
      <url>/2019/10/22/%E5%88%B6%E4%BD%9C%E4%B8%BB%E9%A2%98%E6%97%B6%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>自定义主题的时候遇到的一些问题记录如下：</p><span id="more"></span><ol><li>设置好 index.ejs 布局后 hexo generate 出错</li></ol><pre><code class="bash">ERROR D:\GitHub\RedContritio.github.io\themes\landscape\layout\index.ejs:1 &gt;&gt; 1| &lt;% page.posts.each(function(post)&#123; %&gt;    2|    3| &lt;% &#125;) %&gt;Cannot read property &#39;each&#39; of undefined</code></pre><p>这个现象会出现是因为没有找到其他的布局框架，导致 post 也用 index.ejs 布局，但是 post 页面内无法进行 posts 的迭代从而出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp 入门</title>
      <link href="/2019/10/20/basic-cpp-knowledge/"/>
      <url>/2019/10/20/basic-cpp-knowledge/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++ is a horrible language. It’s made more horrible by the fact that a lot of substandard programmers use it, to the point where it’s much much easier to generate total and utter crap with it. </p><footer><strong>[Linus Torvalds]</strong></footer></blockquote><span id="more"></span><p>为了便于讲解，本文采用由浅及深的方式组织行文主线。</p><p>本文主要采用对比 c 和 cpp 差异的方式来进行。</p><hr><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>几乎所有的 c 语言代码都需要头文件，cpp 和 c 的头文件对比是开始编程前必须的一步。</p><p><em>几乎所有的 c 代码中 <code>#include</code> 命令都可以直接复制到 cpp 中使用，但是这并不推荐</em></p><h3 id="include-是什么？"><a href="#include-是什么？" class="headerlink" title="#include 是什么？"></a>#include 是什么？</h3><pre><code class="c">// module.txtprintf(&quot;%d\n&quot;, a);a *= 3;</code></pre><pre><code class="c">// main.c#include &lt;stdio.h&gt;int main()&#123;    int a = 1, b = 2;#include &quot;module.txt&quot;    printf(&quot;%d %d\n&quot;, a, b);    return 0;&#125;</code></pre><p>编译执行 main.c 后，输出应该是</p><blockquote><p>1</p><p>3 2</p></blockquote><p>可见，<code>#include</code> 作用是将一段文本直接引入到代码中。</p><p>对头文件使用 <code>#include</code> 时也是如此。</p><h3 id="头文件名称对比"><a href="#头文件名称对比" class="headerlink" title="头文件名称对比"></a>头文件名称对比</h3><table><thead><tr><th>语言</th><th>———–</th><th>————</th><th>———–</th><th>———–</th><th>———–</th><th>———–</th></tr></thead><tbody><tr><td>c</td><td>stdio.h</td><td>stdlib.h</td><td>math.h</td><td>\</td><td>windows.h</td><td>string.h</td></tr><tr><td>cpp</td><td>cstdio</td><td>cstdlib</td><td>cmath</td><td>vector</td><td>windows.h</td><td>cstring</td></tr></tbody></table><p>可见，对于常见的头文件，是将 c 头文件的 .h 去掉，在前面加上 c，如 <font size=5><font color=#green>c</font>stdio<font color=red>.h</font> </font> 。</p><p>尤其注意 string.h 文件，cstring 和 string 完全不同。</p><pre><code class="c">// cstdio...#include &lt;stdio.h&gt;...</code></pre><hr><h1 id="IOSTREAM"><a href="#IOSTREAM" class="headerlink" title="IOSTREAM"></a>IOSTREAM</h1><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;...cin &gt;&gt; a;cout &lt;&lt; b;</code></pre><p>上面这一段应该是大多数人最早接触的 cpp 代码。</p><p>大概讲解一下这一段内容中每行代码发生了什么。</p><p><code>#include &lt;iostream&gt;</code> 引入 iostream 头文件</p><p><code>using namespace std;</code> 使用 std 命名空间，命名空间如果有时间放在后面讲。<font color=#E0E0E0>反正也没人用得到不如不讲了。</font></p><p>关于 cin 和 cout，我们可以构造这样一个模型：</p><pre class="mermaid">graph LR;    input-->cin;    cin-->variable;    variable-->cout;    cout-->output;    style cin fill:#CFC,stroke:#333,stroke-width:0.5px    style cout fill:#CFC,stroke:#333,stroke-width:0.5px    style variable fill:#FFC,stroke:#333,stroke-width:0.5px</pre><p>cin 和 cout 仅仅是一个管道，用来让数据从中流过（data stream），这就是所谓的 iostream（input &amp; output stream）。</p><p><code>cin</code> 可以用来输入多个值，如 <code>cin &gt;&gt; a &gt;&gt; b;</code></p><p><code>cin</code> 可以隐式转换为 <code>bool</code> 。</p><p><code>cout</code> 用法同理。</p><hr><h1 id="新的关键字"><a href="#新的关键字" class="headerlink" title="新的关键字"></a>新的关键字</h1><p>本篇只介绍 <code>new</code> 和 <code>delete</code> 。</p><h2 id="简单介绍malloc-系列"><a href="#简单介绍malloc-系列" class="headerlink" title="简单介绍malloc 系列"></a>简单介绍<code>malloc</code> 系列</h2><p><code>malloc</code> 及其内存分配系列函数（如<code>calloc</code> ）均在 stdlib.h 中，而 <code>new</code> 和<code>delete</code> 是语言本身的内存分配机制。</p><p><code>malloc</code> 需要一个参数，<code>void * malloc(size_t _NumOfBytes)</code> ，这个参数表示所需空间的大小，并且不对这段空间进行清空，用法如<code>int *arr = (int *)malloc(n * sizeof(int));</code> 表示分配 n 个 int 的空间。</p><p>其衍生函数，<code>calloc</code> ，需要两个参数，声明形式如<code>void * calloc(int _NumOfElements, size_t SizePerElement)</code> ，用法如<code>int *arr = (int *)calloc(n, sizeof(int));</code> ，需要注意，这个函数分配后会将这一段内存置为 0。</p><h2 id="new-和delete-用法"><a href="#new-和delete-用法" class="headerlink" title="new 和delete 用法"></a><code>new</code> 和<code>delete</code> 用法</h2><p><code>new</code> 用法示例如下：</p><pre><code class="cpp">int *a = new int; // 表示让 a 指向分配的 int 类型值，值未初始化&quot;上面这一行等价于&quot;;int *a = (int*)malloc(sizeof(int));int *b = new int(); // 表示让 b 指向分配的 int 类型值，并在分配后采用默认方式初始化这个值// 对于 int 类型，默认方式初始化意味着置为 0int *c = new int(3); // 表示让 c 指向分配的 int 类型值，并在分配后初始化这个值为 3// *c == 3int *d = new int[n]; // 表示让 d 指向分配的长度为 n 的 int 数组，内存未初始化&quot;上面这一行等价于&quot;;int *d = (int*)malloc(n*sizeof(int));int *e = new int[n](); // 表示让 e 指向分配的长度为 n 的 int 数组，并采用默认方式初始化每个值// e[0] == e[1] == e[2] == ... == e[n-1] == 0// 特别的，有些类型分配的时候略微麻烦一点（类型系统的进阶使用）int **a= new (int *[n]); // 长度为 n 的 int* 数组int (**pf)()= new (int (*)()); // pf 为指向函数指针的指针，指向的函数 f 声明形式如 int f(void);int (**pfs)()= new (int (*[n])()); // pfs 为函数指针数组</code></pre><p><strong>无法用 new 在创建一个数组的同时初始化每个元素</strong></p><hr><p><code>delete</code> 用法类似。（采用<code>new</code> 举例中所用的变量）</p><pre><code class="cpp">delete a;delete b;delete c;delete []d; // 删除数组delete []e;</code></pre><hr><h2 id="new-的思考"><a href="#new-的思考" class="headerlink" title="new 的思考"></a><code>new</code> 的思考</h2><p>能否用<code>new</code> 在创建一个数组后初始化每个元素呢？<font color=white> placement new </font></p><h1 id="函数多态（重载）与默认参数"><a href="#函数多态（重载）与默认参数" class="headerlink" title="函数多态（重载）与默认参数"></a>函数多态（重载）与默认参数</h1><h2 id="函数多态"><a href="#函数多态" class="headerlink" title="函数多态"></a>函数多态</h2><p>例如，我们有</p><pre><code class="cpp">int max(int a, int b) &#123; return a&gt;b?a:b;&#125;</code></pre><p>如果我们想要三个数比较该怎么做？</p><p>在 c 中，</p><pre><code class="c">int max3i(int a, int b, int c) &#123; int t = max(a, b); return t&gt;c?t:c;&#125;</code></pre><p>而在 cpp 中，我们可以直接使用</p><pre><code class="cpp">int max(int a, int b, int c) &#123; int t = max(a, b); return t&gt;c?t:c;&#125;</code></pre><p>cpp 可以根据参数的数量和类型来自动判断调用哪一个函数。</p><p>以至于我们可以</p><pre><code class="cpp">int max(int a) &#123; int t = a; return t&gt;a?t:a;&#125;int max(int a, int b) &#123; int t = max(b); return t&gt;a?t:a;&#125;int max(int a, int b, int c) &#123; int t = max(b, c); return t&gt;a?t:a;&#125;int max(int a, int b, int c, int d) &#123; int t = max(b, c, d); return t&gt;a?t:a;&#125;int max(int a, int b, int c, int d, int e) &#123; int t = max(b, c, d, e); return t&gt;a?t:a;&#125;int max(int a, int b, int c, int d, int e, int f) &#123; int t = max(b, c, d, e, f); return t&gt;a?t:a;&#125;</code></pre><p>这时候我们可以传入 1-6 个参数来最大值，并且除了单个参数的情况，其他具有一致性。</p><p>再例如，常见的错误代码 <code>int a = pow(5, 2)</code> ，我们可以定义 pow 的多态：</p><pre><code class="cpp">int pow(int a, int n)&#123;    if(n&lt;0) return 0;    int res = 1;    for(int i=0; i&lt;n; ++i) res *= a;    return a;&#125;</code></pre><p>可以避免浮点误差。</p><hr><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>上面介绍了函数多态，这里介绍函数默认参数。</p><p>例如我们需要一个求和函数，我们预定有四个数字要被传入。</p><pre><code class="cpp">int sum(int a, int b, int c, int d) &#123; return a+b+c+d;&#125;</code></pre><p>但是随着时间流逝，我们有时候需要传入三个参数。</p><pre><code class="cpp">int sum(int a, int b, int c) &#123; return sum(a, b, c, 0);&#125;</code></pre><p>以及两个······</p><pre><code class="cpp">int sum(int a, int b) &#123; return sum(a, b, 0);&#125;</code></pre><p>甚至一个············</p><pre><code class="cpp">int sum(int a) &#123; return sum(a, 0);&#125;</code></pre><p>甚至没有参数<del>（👈这样的函数有意义吗？？？）</del></p><pre><code class="cpp">int sum(void) &#123; return sum(0);&#125;</code></pre><p>这里的求和函数和上面的 max 形式很像，并且一路规约下来也很自然，只是略微冗杂了点。</p><p>能不能更简单呢？</p><p><font size=7>能！</font></p><p>cpp 允许函数含有默认参数。</p><p>上面的 <code>sum</code> 系列函数使用默认参数后只需要一个函数即可。</p><pre><code class="cpp">int sum(int a=0, int b=0, int c=0, int d=0) &#123; return a+b+c+d;&#125;</code></pre><p>这个函数的定义表示，如果没有传入对应参数，则对应参数默认置为 0。</p><p>如 <code>sum(1,2,3)</code> ，其中各参数即为<code>a=1, b=2, c=3, d=0</code> 。</p><p>在 cpp 中，各参数只能从左向右排布，因此默认参数需要从右向左赋值。</p><p>函数的默认参数只能在声明或定义中出现一次。</p><hr><h1 id="新的类型"><a href="#新的类型" class="headerlink" title="新的类型"></a>新的类型</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用类型是值和指针的折中。</p><p>引用的主要用途是函数传参和创建别名。</p><p>函数传递较大的数据类型由于需要整个拷贝，因此在 c 中通常传递指针作为参数，例如：</p><pre><code class="c">typedef struct data&#123;    int a[1000000];    int b[1000000];&#125;data, *pdate;int f(pdata p)&#123;    pdata-&gt;a ...    pdata-&gt;b ...&#125;</code></pre><p>但是频繁的指针操作并不优雅，因此我们使用引用。</p><pre><code class="cpp">int f(data&amp; d)&#123;    d.a ...    d.b ...&#125;</code></pre><p>在这里我们可以像使用一个 data 类型一样使用 data&amp; 类型。</p><p>引用和其实体共享一个对象，例如</p><pre><code class="cpp">int a = 2;int &amp;b = a;b = 3;</code></pre><p>此时 a 也被改变。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>类是类似结构体的数据类型。</p><pre><code class="cpp">struct A&#123;    int a;&#125; a;class B&#123;    int b;&#125; b;int main()&#123;    printf(&quot;%d\n&quot;, a.a);    printf(&quot;%d\n&quot;, b.b);&#125;</code></pre><p>类的内容默认对外不开放。</p><p>类内可以定义函数（方法）。</p><pre><code class="cpp">class B&#123;public:    int print();private:    int b;&#125; b;</code></pre><p>public 表示类外可以访问，private 表示类外无法访问。</p><p>这时候我们可以使用 b.print() 来输出，但是不能修改 b.b 的内容。 </p><p>特别的，cpp 中的 struct 也不同于 c 中的，它更像是被修改了默认访问权限的 class。</p><hr><h1 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h1><h2 id="内联的好处"><a href="#内联的好处" class="headerlink" title="内联的好处"></a>内联的好处</h2><p>宏是一种功能强大的预处理工具。</p><p>但是含有隐患。</p><pre><code class="c">#define mult(a, b) a*b</code></pre><p>如果使用 </p><pre><code class="c">int x = mult(3+2,2+3);</code></pre><p>如常理所想应该是 x 被赋值为 (3+2)*(2+3) &#x3D;&#x3D; 25，但是实际上，这句在展开后会成为</p><pre><code class="c">int x = 3+2*2+3; // x == 10</code></pre><p>诚然，我们可以采用加括号的方式来封闭宏，但是总有力所不逮之处（为什么不行？思考题）。</p><p>因此，cpp 创建了内联的语法。</p><pre><code>inline int mult(int a, int b) &#123; return a*b;&#125;int x = mult(3+2,2+3);</code></pre><p>这时候，第二行<code>int x = mult(3+2,2+3);</code> 就相当于展开成这样的三行：</p><pre><code class="cpp">int a = 3+2;int b = 2+3;int x = a*b;</code></pre><p>可以确保其正确性。</p><h2 id="为什么还要宏？"><a href="#为什么还要宏？" class="headerlink" title="为什么还要宏？"></a>为什么还要宏？</h2><p>内联如此方便、强大、安全，为什么要宏呢？</p><p>这里是宏的一些（内联做不到的）用法：</p><pre><code class="cpp">#include &lt;cstdio&gt;int test_function(void);int main()&#123;    test_function();    printf(&quot;%s\n&quot;, __FUNCTION__);&#125;int test_function(void)&#123;    printf(&quot;%s\n&quot;, __FUNCTION__);&#125;</code></pre><hr><p>例如上面的 <code>mult</code> ，也可以使用宏的方式来正确处理。</p><pre><code class="cpp">#define mult(a, b) ((a)*(b))</code></pre><p>但是，它在维持原有参数结构的情况下，不能做到和内联一样安全。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 社团课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看板娘配置</title>
      <link href="/2019/10/20/%E7%9C%8B%E6%9D%BF%E5%A8%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/20/%E7%9C%8B%E6%9D%BF%E5%A8%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="看板娘配置"><a href="#看板娘配置" class="headerlink" title="看板娘配置"></a>看板娘配置</h3><p>参考网上教程配置了 Live2D 看板娘。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装框架"><a href="#安装框架" class="headerlink" title="安装框架"></a>安装框架</h3><p>根目录下，执行</p><pre><code class="bash">npm install --save hexo-helper-live2d</code></pre><p>此后在根目录下 __config.yml 中新增：</p><pre><code class="bash"># Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d:  enable: true  # enable: false  scriptFrom: local # 默认  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径  pluginModelPath: assets/ # 模型文件相对与插件根目录路径  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: false # 调试, 是否在控制台输出日志  model:    use: live2d-widget-model-wanko # npm-module package name    # use: wanko # 博客根目录/live2d_models/ 下的目录名    #use: ./source/live2d/wanko # 相对于博客根目录的路径    # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url  display:    position: right    width: 150    height: 300  mobile:    show: false # 手机中是否展示    scale: 0.5</code></pre><h3 id="安装模型"><a href="#安装模型" class="headerlink" title="安装模型"></a>安装模型</h3><p>安装模型有两种方式，第一种是通过 npm 下载，如：</p><pre><code class="bash">npm install live2d-widget-model-wanko</code></pre><p>另一种方式是自行下载包，安装到任意位置，此后在 __config.yml 中 live2d-&gt;model 写明适当位置即可。</p><hr><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>根目录下执行</p><pre><code class="bash">npm uninstall hexo-helper-live2d</code></pre><hr><p><em>感谢 <a href="https://sevencho.github.io/">曹雪松de博客|CoderBoy’s Blog</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点搭建过程</title>
      <link href="/2019/10/20/%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/10/20/%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="站点搭建过程"><a href="#站点搭建过程" class="headerlink" title="站点搭建过程"></a>站点搭建过程</h1><p>基于 hexo 搭建了自己的站点，在此发布一下搭建教程。</p><span id="more"></span><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>配置 node.js</li><li>配置 hexo</li></ul><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><ul><li>设置 theme</li></ul><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><ol><li><p><code>hexo new &lt;title&gt;</code></p><p>创建新文章</p></li><li><p><code>hexo g</code></p><p>构建静态页面(<code>hexo generate</code> )</p></li><li><p><code>hexo clean</code></p><p>清除已构建的页面</p></li><li><p><code>hexo s</code></p><p>本地服务器(<code>hexo server</code>)</p></li><li><p><code>hexo d</code></p><p>发布、部署(<code>hexo deploy</code>)</p></li></ol><h2 id="NPM-代理"><a href="#NPM-代理" class="headerlink" title="NPM 代理"></a>NPM 代理</h2><p>特别的，如果 <code>ping raw.githubusercontent.com</code> 不通，可能需要设置代理。以本机为例，代理设置方式：</p><pre><code class="ps1">npm config set proxy=http://127.0.0.1:7890npm config set registry=http://registry.npmjs.org</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 维护 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
