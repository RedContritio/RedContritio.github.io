<!doctype html><head><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=icon type=image/x-icon href=/images/favicon.ico><link rel="shortcut icon" type=image/x-icon href=/images/favicon.ico><title>Cpp 入门 - Chireiden</title><meta name=author content="RedContritio"><meta name=description content="地霊殿，充满幻想与希望的殿堂"><meta name=keywords content="社团课程"><meta property="og:title" content="Cpp 入门"><meta property="og:description" content="
  
C++ is a horrible language. It's made more horrible by the fact that a lot of substandard programmers use it, to the point where it's much much easier to generate total and utter crap with it.

  Linus Torvalds
"><meta property="og:type" content="article"><meta property="og:url" content="https://RedContritio.github.io/2019/10/cpp-%E5%85%A5%E9%97%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-20T21:06:47+08:00"><meta property="article:modified_time" content="2019-10-20T21:06:47+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cpp 入门"><meta name=twitter:description content="
  
C++ is a horrible language. It's made more horrible by the fact that a lot of substandard programmers use it, to the point where it's much much easier to generate total and utter crap with it.

  Linus Torvalds
"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<link rel=stylesheet href=https://RedContritio.github.io/scss/main.min.7eb360f545dea4e461c361ba2b40f8b68bf2f8129d711aab867c8748ca5a8c07.css integrity="sha256-frNg9UXepORhw2G6K0D4tovy+BKdcRqrhnyHSMpajAc=" crossorigin=anonymous media=screen><link href=//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css rel=stylesheet></head></head><body><span class="mobile btn-mobile-menu"><i class="fa fa-list btn-mobile-menu__icon"></i>
<i class="fa fa-angle-up btn-mobile-close__icon hidden"></i></span><header class="panel-cover panel-cover--collapsed" style=background-image:url(/images/background-cover.jpg)><div class=panel-main><div class="panel-main__inner panel-inverted"><div class=panel-main__content><a href=/#blog title="Homepage of Chireiden " class=blog-button><img src=/images/avatar.jpg width=80 alt="Chireiden logo" class="panel-cover__logo logo"></a><h1 class="panel-cover__title panel-title"><a href=/#blog title="Homepage of Chireiden" class=blog-button>Chireiden</a></h1><span class="panel-cover__subtitle panel-subtitle">地霊殿</span><hr class=panel-cover__divider><p class=panel-cover__description>地霊殿，充满幻想与希望的殿堂</p><hr class="panel-cover__divider panel-cover__divider--secondary"><p class=panel-cover__description>夢も希望も無い、毎日がそんな生活だった。</p><div class=navigation-wrapper><div><nav class="cover-navigation cover-navigation--primary"><ul class=navigation><li class=navigation__item><a href=/#blog title=Blog class=blog-button>Blog</a></li><li class=navigation__item><a href=/tags/ target=_blank title=Tags>Tags</a></li><li class=navigation__item><a href=/friends/ target=_blank title=Friends>Friends</a></li><li class=navigation__item><a href=/about/ target=_blank title=About>About</a></li></ul></nav></div><div><nav class="cover-navigation navigation--social"><ul class=navigation><li class=navigation__item><a href=https://github.com/RedContritio title=@RedContritio target=_blank><i class='social fa fa-github'></i>
<span class=label>Github</span></a></li><li class=navigation__item><a href=/index.xml rel=author title=RSS target=_blank><i class='social fa fa-rss'></i>
<span class=label>RSS</span></a></li><li class=navigation__item><a href=mailto:RedContritio@qq.com title="Contact me"><i class='social fa fa-envelope'></i>
<span class=label>Email</span></a></li></ul></nav></div></div></div></div><div class="panel-cover--overlay cover-light-red"></div></div></header><div class=content-wrapper><div class=content-wrapper__inner><article class="post-container post-container--single" itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><div class=post-meta><time datetime=" 2019-10-20 21:06:47 +0800 " itemprop=datePublished class="post-meta__date date">2019-10-20</time>
<span class="post-meta__tags tags">• <a href=https://RedContritio.github.io/tags/%E7%A4%BE%E5%9B%A2%E8%AF%BE%E7%A8%8B>社团课程</a></span></div><h1 class=post-title>Cpp 入门</h1></header><section class=post><nav id=TableOfContents><ul><li><a href=#头文件>头文件</a><ul><li><a href=#include-是什么>#include 是什么？</a></li><li><a href=#头文件名称对比>头文件名称对比</a></li></ul></li><li><a href=#iostream>IOSTREAM</a></li><li><a href=#新的关键字>新的关键字</a><ul><li><a href=#简单介绍malloc-系列>简单介绍<code>malloc</code> 系列</a></li><li><a href=#new-和delete-用法><code>new</code> 和<code>delete</code> 用法</a></li><li><a href=#new-的思考><code>new</code> 的思考</a></li></ul></li><li><a href=#函数多态重载与默认参数>函数多态（重载）与默认参数</a><ul><li><a href=#函数多态>函数多态</a></li><li><a href=#默认参数>默认参数</a></li></ul></li><li><a href=#新的类型>新的类型</a><ul><li><a href=#引用>引用</a></li><li><a href=#class>class</a></li></ul></li><li><a href=#内联与宏>内联与宏</a><ul><li><a href=#内联的好处>内联的好处</a></li><li><a href=#为什么还要宏>为什么还要宏？</a></li></ul></li></ul></nav><blockquote>C++ is a horrible language. It's made more horrible by the fact that a lot of substandard programmers use it, to the point where it's much much easier to generate total and utter crap with it.<footer>Linus Torvalds</footer></blockquote><p>为了便于讲解，本文采用由浅及深的方式组织行文主线。</p><p>本文主要采用对比 c 和 cpp 差异的方式来进行。</p><hr><h2 id=头文件>头文件</h2><p>几乎所有的 c 语言代码都需要头文件，cpp 和 c 的头文件对比是开始编程前必须的一步。</p><p><em>几乎所有的 c 代码中 <code>#include</code> 命令都可以直接复制到 cpp 中使用，但是这并不推荐</em></p><h3 id=include-是什么>#include 是什么？</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// module.txt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, a);
</span></span><span style=display:flex><span>a <span style=color:#f92672>*=</span> <span style=color:#ae81ff>3</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>##include &lt;stdio.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>##include &#34;module.txt&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, a, b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译执行 main.c 后，输出应该是</p><blockquote><p>1</p><p>3 2</p></blockquote><p>可见，<code>#include</code> 作用是将一段文本直接引入到代码中。</p><p>对头文件使用 <code>#include</code> 时也是如此。</p><h3 id=头文件名称对比>头文件名称对比</h3><table><thead><tr><th>语言</th><th>&mdash;&mdash;&mdash;&ndash;</th><th>&mdash;&mdash;&mdash;&mdash;</th><th>&mdash;&mdash;&mdash;&ndash;</th><th>&mdash;&mdash;&mdash;&ndash;</th><th>&mdash;&mdash;&mdash;&ndash;</th><th>&mdash;&mdash;&mdash;&ndash;</th></tr></thead><tbody><tr><td>c</td><td>stdio.h</td><td>stdlib.h</td><td>math.h</td><td>\|windows.h</td><td>string.h</td><td></td></tr><tr><td>cpp</td><td>cstdio</td><td>cstdlib</td><td>cmath</td><td>vector</td><td>windows.h</td><td>cstring</td></tr></tbody></table><p>可见，对于常见的头文件，是将 c 头文件的 .h 去掉，在前面加上 c，如 cstdio.h  。</p><p>尤其注意 string.h 文件，cstring 和 string 完全不同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// cstdio
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;stdio.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span></code></pre></div><hr><h2 id=iostream>IOSTREAM</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>##include &lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>cin <span style=color:#f92672>&gt;&gt;</span> a;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> b;
</span></span></code></pre></div><p>上面这一段应该是大多数人最早接触的 cpp 代码。</p><p>大概讲解一下这一段内容中每行代码发生了什么。</p><p><code>#include &lt;iostream></code> 引入 iostream 头文件</p><p><code>using namespace std;</code> 使用 std 命名空间，命名空间如果有时间放在后面讲。反正也没人用得到不如不讲了。</p><p>关于 cin 和 cout，我们可以构造这样一个模型：</p><script src=//cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,fontFamily:'Consolas, "Courier New", monospace'})</script><div class=mermaid>graph LR;
input["input"]-->cin["cin"];
cin["cin"]-->variable["variable"];
variable["variable"]-->cout["cout"];
cout["cout"]-->output["output"];
style cin fill:#CFC,stroke:#333,stroke-width:0.5px
style cout fill:#CFC,stroke:#333,stroke-width:0.5px
style variable fill:#FFC,stroke:#333,stroke-width:0.5px</div><p>cin 和 cout 仅仅是一个管道，用来让数据从中流过（data stream），这就是所谓的 iostream（input & output stream）。</p><p><code>cin</code> 可以用来输入多个值，如 <code>cin >> a >> b;</code></p><p><code>cin</code> 可以隐式转换为 <code>bool</code> 。</p><p><code>cout</code> 用法同理。</p><hr><h2 id=新的关键字>新的关键字</h2><p>本篇只介绍 <code>new</code> 和 <code>delete</code> 。</p><h3 id=简单介绍malloc-系列>简单介绍<code>malloc</code> 系列</h3><p><code>malloc</code> 及其内存分配系列函数（如<code>calloc</code> ）均在 stdlib.h 中，而 <code>new</code> 和<code>delete</code> 是语言本身的内存分配机制。</p><p><code>malloc</code> 需要一个参数，<code>void * malloc(size_t _NumOfBytes)</code> ，这个参数表示所需空间的大小，并且不对这段空间进行清空，用法如<code>int *arr = (int *)malloc(n * sizeof(int));</code> 表示分配 n 个 int 的空间。</p><p>其衍生函数，<code>calloc</code> ，需要两个参数，声明形式如<code>void * calloc(int _NumOfElements, size_t SizePerElement)</code> ，用法如<code>int *arr = (int *)calloc(n, sizeof(int));</code> ，需要注意，这个函数分配后会将这一段内存置为 0。</p><h3 id=new-和delete-用法><code>new</code> 和<code>delete</code> 用法</h3><p><code>new</code> 用法示例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>; <span style=color:#75715e>// 表示让 a 指向分配的 int 类型值，值未初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;上面这一行等价于&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(); <span style=color:#75715e>// 表示让 b 指向分配的 int 类型值，并在分配后采用默认方式初始化这个值
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 对于 int 类型，默认方式初始化意味着置为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// 表示让 c 指向分配的 int 类型值，并在分配后初始化这个值为 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>// *c == 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n]; <span style=color:#75715e>// 表示让 d 指向分配的长度为 n 的 int 数组，内存未初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;上面这一行等价于&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>d <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)malloc(n<span style=color:#f92672>*</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n](); <span style=color:#75715e>// 表示让 e 指向分配的长度为 n 的 int 数组，并采用默认方式初始化每个值
</span></span></span><span style=display:flex><span><span style=color:#75715e>// e[0] == e[1] == e[2] == ... == e[n-1] == 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 特别的，有些类型分配的时候略微麻烦一点（类型系统的进阶使用）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>a<span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>[n]); <span style=color:#75715e>// 长度为 n 的 int* 数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> (<span style=color:#f92672>**</span>pf)()<span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (<span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)()); <span style=color:#75715e>// pf 为指向函数指针的指针，指向的函数 f 声明形式如 int f(void);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> (<span style=color:#f92672>**</span>pfs)()<span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> (<span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>[n])()); <span style=color:#75715e>// pfs 为函数指针数组
</span></span></span></code></pre></div><p><strong>无法用 new 在创建一个数组的同时初始化每个元素</strong></p><hr><p><code>delete</code> 用法类似。（采用<code>new</code> 举例中所用的变量）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>delete</span> a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> []d; <span style=color:#75715e>// 删除数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> []e;
</span></span></code></pre></div><hr><h3 id=new-的思考><code>new</code> 的思考</h3><p>能否用<code>new</code> 在创建一个数组后初始化每个元素呢？ placement new</p><h2 id=函数多态重载与默认参数>函数多态（重载）与默认参数</h2><h3 id=函数多态>函数多态</h3><p>例如，我们有</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>return</span> a<span style=color:#f92672>&gt;</span>b<span style=color:#f92672>?</span>a:b;}
</span></span></code></pre></div><p>如果我们想要三个数比较该怎么做？</p><p>在 c 中，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max3i</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(a, b); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>c<span style=color:#f92672>?</span>t:c;}
</span></span></code></pre></div><p>而在 cpp 中，我们可以直接使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(a, b); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>c<span style=color:#f92672>?</span>t:c;}
</span></span></code></pre></div><p>cpp 可以根据参数的数量和类型来自动判断调用哪一个函数。</p><p>以至于我们可以</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> a; <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(b); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(b, c); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(b, c, d); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d, <span style=color:#66d9ef>int</span> e) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(b, c, d, e); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d, <span style=color:#66d9ef>int</span> e, <span style=color:#66d9ef>int</span> f) { <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> max(b, c, d, e, f); <span style=color:#66d9ef>return</span> t<span style=color:#f92672>&gt;</span>a<span style=color:#f92672>?</span>t:a;}
</span></span></code></pre></div><p>这时候我们可以传入 1-6 个参数来最大值，并且除了单个参数的情况，其他具有一致性。</p><p>再例如，常见的错误代码 <code>int a = pow(5, 2)</code> ，我们可以定义 pow 的多态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pow</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(n<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; <span style=color:#f92672>++</span>i) res <span style=color:#f92672>*=</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以避免浮点误差。</p><hr><h3 id=默认参数>默认参数</h3><p>上面介绍了函数多态，这里介绍函数默认参数。</p><p>例如我们需要一个求和函数，我们预定有四个数字要被传入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) { <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b<span style=color:#f92672>+</span>c<span style=color:#f92672>+</span>d;}
</span></span></code></pre></div><p>但是随着时间流逝，我们有时候需要传入三个参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c) { <span style=color:#66d9ef>return</span> sum(a, b, c, <span style=color:#ae81ff>0</span>);}
</span></span></code></pre></div><p>以及两个······</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>return</span> sum(a, b, <span style=color:#ae81ff>0</span>);}
</span></span></code></pre></div><p>甚至一个············</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a) { <span style=color:#66d9ef>return</span> sum(a, <span style=color:#ae81ff>0</span>);}
</span></span></code></pre></div><p>甚至没有参数（👈这样的函数有意义吗？？？）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>void</span>) { <span style=color:#66d9ef>return</span> sum(<span style=color:#ae81ff>0</span>);}
</span></span></code></pre></div><p>这里的求和函数和上面的 max 形式很像，并且一路规约下来也很自然，只是略微冗杂了点。</p><p>能不能更简单呢？</p><p>能！</p><p>cpp 允许函数含有默认参数。</p><p>上面的 <code>sum</code> 系列函数使用默认参数后只需要一个函数即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> d<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>return</span> a<span style=color:#f92672>+</span>b<span style=color:#f92672>+</span>c<span style=color:#f92672>+</span>d;}
</span></span></code></pre></div><p>这个函数的定义表示，如果没有传入对应参数，则对应参数默认置为 0。</p><p>如 <code>sum(1,2,3)</code> ，其中各参数即为<code>a=1, b=2, c=3, d=0</code> 。</p><p>在 cpp 中，各参数只能从左向右排布，因此默认参数需要从右向左赋值。</p><p>函数的默认参数只能在声明或定义中出现一次。</p><hr><h2 id=新的类型>新的类型</h2><h3 id=引用>引用</h3><p>引用类型是值和指针的折中。</p><p>引用的主要用途是函数传参和创建别名。</p><p>函数传递较大的数据类型由于需要整个拷贝，因此在 c 中通常传递指针作为参数，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> data
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>1000000</span>];
</span></span><span style=display:flex><span>}data, <span style=color:#f92672>*</span>pdate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(pdata p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pdata<span style=color:#f92672>-&gt;</span>a ...
</span></span><span style=display:flex><span>    pdata<span style=color:#f92672>-&gt;</span>b ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是频繁的指针操作并不优雅，因此我们使用引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(data<span style=color:#f92672>&amp;</span> d)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	d.a ...
</span></span><span style=display:flex><span>	d.b ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里我们可以像使用一个 data 类型一样使用 data& 类型。</p><p>引用和其实体共享一个对象，例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span></code></pre></div><p>此时 a 也被改变。</p><h3 id=class>class</h3><p>类是类似结构体的数据类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>} a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span>} b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, a.a);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, b.b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>类的内容默认对外不开放。</p><p>类内可以定义函数（方法）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> print();
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span>} b;
</span></span></code></pre></div><p>public 表示类外可以访问，private 表示类外无法访问。</p><p>这时候我们可以使用 b.print() 来输出，但是不能修改 b.b 的内容。</p><p>特别的，cpp 中的 struct 也不同于 c 中的，它更像是被修改了默认访问权限的 class。</p><hr><h2 id=内联与宏>内联与宏</h2><h3 id=内联的好处>内联的好处</h3><p>宏是一种功能强大的预处理工具。</p><p>但是含有隐患。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>##define mult(a, b) a*b
</span></span></span></code></pre></div><p>如果使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#a6e22e>mult</span>(<span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>);
</span></span></code></pre></div><p>如常理所想应该是 x 被赋值为 (3+2)*(2+3) == 25，但是实际上，这句在展开后会成为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>; <span style=color:#75715e>// x == 10
</span></span></span></code></pre></div><p>诚然，我们可以采用加括号的方式来封闭宏，但是总有力所不逮之处（为什么不行？思考题）。</p><p>因此，cpp 创建了内联的语法。</p><pre tabindex=0><code>inline int mult(int a, int b) { return a*b;}
int x = mult(3+2,2+3);
</code></pre><p>这时候，第二行<code>int x = mult(3+2,2+3);</code> 就相当于展开成这样的三行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> a<span style=color:#f92672>*</span>b;
</span></span></code></pre></div><p>可以确保其正确性。</p><h3 id=为什么还要宏>为什么还要宏？</h3><p>内联如此方便、强大、安全，为什么要宏呢？</p><p>这里是宏的一些（内联做不到的）用法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>##include &lt;cstdio&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>test_function</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    test_function();
</span></span><span style=display:flex><span>	printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __FUNCTION__);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>test_function</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, __FUNCTION__);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>例如上面的 <code>mult</code> ，也可以使用宏的方式来正确处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>##define mult(a, b) ((a)*(b))
</span></span></span></code></pre></div><p>但是，它在维持原有参数结构的情况下，不能做到和内联一样安全。</p></section></article><section class=read-more><div class=read-more-header><div class="read-more-header-item read-more-item"><span class=read-more-item-dim>Recent</span><h2 class="post-list__post-title post-title"><a href=/2019/10/%E5%88%B6%E4%BD%9C%E4%B8%BB%E9%A2%98%E6%97%B6%E8%B8%A9%E7%9A%84%E5%9D%91/ title="link to 制作主题时踩的坑">制作主题时踩的坑</a></h2></div><div class="read-more-header-item read-more-item"><span class=read-more-item-dim>Earlier</span><h2 class="post-list__post-title post-title"><a href=/2019/10/%E7%9C%8B%E6%9D%BF%E5%A8%98%E9%85%8D%E7%BD%AE/ title="link to 看板娘配置">看板娘配置</a></h2></div></div><div class=read-more-summary><div class="read-more-summary-item read-more-item"><p class=excerpt><p>自定义主题的时候遇到的一些问题记录如下：</p>&mldr;</p></div><div class="read-more-summary-item read-more-item"><p class=excerpt><h3 id=看板娘配置>看板娘配置</h3><p>参考网上教程配置了 Live2D 看板娘。</p>&mldr;</p></div></div><div class=read-more-meta><div class="read-more-meta-item read-more-item"><time datetime="2019-10-20 21:06:47 +0800" class="post-list__meta--date date">2019-10-22</time>
<span class="post-list__meta--tags tags">• <a href=https://RedContritio.github.io/tags/%E7%BB%B4%E6%8A%A4>维护</a></span>
<a class=btn-border-small href=/2019/10/%E5%88%B6%E4%BD%9C%E4%B8%BB%E9%A2%98%E6%97%B6%E8%B8%A9%E7%9A%84%E5%9D%91/>Continue</a></div><div class="read-more-meta-item read-more-item"><time datetime="2019-10-20 21:06:47 +0800" class="post-list__meta--date date">2019-10-20</time>
<span class="post-list__meta--tags tags">• <a href=https://RedContritio.github.io/tags/%E7%BB%B4%E6%8A%A4>维护</a></span>
<a class=btn-border-small href=/2019/10/%E7%9C%8B%E6%9D%BF%E5%A8%98%E9%85%8D%E7%BD%AE/>Continue</a></div></div></section><section class=post-comments><div id=gitalk-container><script>var gitalk=new Gitalk({clientID:"0a6a884a25f2cfcd11b3",clientSecret:"63fa88190fa69c3d00d744d99b78af1b13f595ec",repo:"RedContritio.github.io",owner:"RedContritio",admin:["RedContritio"],id:"c3acff564b00fb2a5d8207d9c1c5e871_2019-10-20",distractionFreeMode:!1});gitalk.render("gitalk-container")</script></div></section><section class=footer><footer><span class=footer__copyright>This site is licensed under a <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> license.</span>
<span class=footer__copyright>Generated by <a href=https://gohugo.io/>Hugo</a> at 2024-03-08, themed with <a href=https://github.com/xslingcn/vno-hugo>Vno - Hugo</a>.</span></footer></section></div></div><script type=text/javascript src=//code.jquery.com/jquery-1.11.3.min.js></script>
<script type=text/javascript src=/js/main.js></script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","your_ga_id","your_host"),ga("send","pageview")</script></body>